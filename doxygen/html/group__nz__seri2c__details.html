<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>Netcruzer Library API: I2C Serial Ports</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Netcruzer Library API
   &#160;<span id="projectnumber">V2.03</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__nz__seri2c__details.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">I2C Serial Ports</div>  </div>
</div><!--header-->
<div class="contents">
<p>Netcruzer boards have 2 to 3 I2C ports. They are all interrupt based, meaning once a message is written to the queue, it is processed in the background by an interrupt service routine. Functions are provided for querying the status of a transmission, and reading data read from the I2C port.</p>
<p>For details on serial ports, see the <a class="el" href="nz__ser_i2_c_8h.html#nz_seri2c_desc">nz_serI2C.h Documentation</a>.</p>
<h1><a class="anchor" id="nz_seri2c_details"></a>
Details</h1>
<p>This module implements an I2C Master, and provides functions for communicating with slave devices. All I2C communication is done in the background via I2C interrupts. Transmit and receive Queues (Circular Buffers) are used for writing and reading data to and from I2C devices.</p>
<h2><a class="anchor" id="nz_seri2c_write"></a>
Writing to the I2C Port</h2>
<p>To sent data to an I2C device, the message is written to the Transmit Queue (Circular Buffer) by using the provided i2c1Xxx to i2c3Xxx functions, like <a class="el" href="nz__ser_i2_c_8h.html#a296d883d2efc94de4b2b473a1580bdde">i2c1Write()</a> for example. To get status of transmission, see <a class="el" href="group__nz__seri2c__details.html#nz_seri2c_status">Status of I2C Transmission</a> section below. The Transmit Queue is monitored in the background via the I2C interrupts, and if it contains data, is written out via the I2C bus. There are a couple of different ways of doing this (I2C 1 functions shown, replace 1 with 2 or 3 for other I2C ports):</p>
<ul>
<li>Using the <a class="el" href="nz__ser_i2_c_8h.html#abf5d624c9e75d28fd11b587caa239a34">i2c1BeginTransmission()</a>, <a class="el" href="nz__ser_i2_c_8h.html#a296d883d2efc94de4b2b473a1580bdde">i2c1Write()</a> and <a class="el" href="nz__ser_i2_c_8h.html#a3476629591dc4ab13522243cec246686">i2c1EndTransmission()</a> functions.</li>
<li>Preparing the message in a BYTE array, and sending it via the <a class="el" href="nz__ser_i2_c_8h.html#ab04ea0534474b2a6a446d507021ba2f4">i2c1WriteMessage()</a> function.</li>
<li>Sending a message in "ASCII Format, with Escape Sequences" using the <a class="el" href="nz__ser_i2_c_8h.html#a733cb0297e0660d0de078727ef4e9ccb">i2c1WriteAsciiEscString()</a> function.</li>
<li>ADVANCED! Using Circular Buffer functions, and adding the message direct to the Transmit Circular Buffer for the required I2C bus. See "Advanced" section below for details.</li>
</ul>
<p>For example, to write two bytes (0x80 and 0xA7) to a device with address 0x60, the following code can be used. </p>
<div class="fragment"><div class="line"><a class="code" href="nz__ser_i2_c_8h.html#abf5d624c9e75d28fd11b587caa239a34">i2c1BeginTransmission</a>(0x60);</div>
<div class="line"><a class="code" href="nz__ser_i2_c_8h.html#a296d883d2efc94de4b2b473a1580bdde">i2c1Write</a>(0x80);</div>
<div class="line"><a class="code" href="nz__ser_i2_c_8h.html#a296d883d2efc94de4b2b473a1580bdde">i2c1Write</a>(0xA7);</div>
<div class="line"><a class="code" href="nz__ser_i2_c_8h.html#a3476629591dc4ab13522243cec246686">i2c1EndTransmission</a>();</div>
</div><!-- fragment --><p> Alternatively the <a class="el" href="nz__ser_i2_c_8h.html#ab04ea0534474b2a6a446d507021ba2f4">i2c1WriteMessage()</a> function can be used to send an I2C message. The example above can be replaced by the following code. </p>
<div class="fragment"><div class="line">BYTE msg[] = {0x80, 0xA7};</div>
<div class="line"><a class="code" href="nz__ser_i2_c_8h.html#ab04ea0534474b2a6a446d507021ba2f4">i2c1WriteMessage</a>(0x60, msg, <span class="keyword">sizeof</span>(msg));</div>
</div><!-- fragment --><p> or </p>
<div class="fragment"><div class="line"><a class="code" href="nz__ser_i2_c_8h.html#ab04ea0534474b2a6a446d507021ba2f4">i2c1WriteMessage</a>(0x60, (BYTE*)<span class="stringliteral">&quot;\x80\xA7&quot;</span>, <span class="keyword">sizeof</span>(msg)); <span class="comment">//Write Byte 1=0x80, Byte2=0xA7 to slave at 0x60</span></div>
</div><!-- fragment --><p> Using the <a class="el" href="nz__ser_i2_c_8h.html#a733cb0297e0660d0de078727ef4e9ccb">i2c1WriteAsciiEscString()</a> function, the following code can be used: </p>
<div class="fragment"><div class="line"><a class="code" href="nz__ser_i2_c_8h.html#a733cb0297e0660d0de078727ef4e9ccb">i2c1WriteAsciiEscString</a>(<span class="stringliteral">&quot;6080A7&quot;</span>);</div>
</div><!-- fragment --><p> The <a class="el" href="nz__ser_i2_c_8h.html#a733cb0297e0660d0de078727ef4e9ccb">i2c1WriteAsciiEscString()</a> function uses "ASCII Format, with Escape Sequences" (Control Characters). This format uses 2 upper case characters to represent a single hex character. Strings must be enclosed within single quotation marks('). Lower case characters 'a' to 'z' are used to represent "Control characters". See <a class="el" href="nz__circular_buffer_8h.html#nz_circularBuffer_format_ascii_esc">ASCII Format, with Escape Sequence</a> for details. The following <b>Control Characters</b> are defined:</p>
<ul>
<li><b>s and p</b>: Put Start(s) and Stop(p) Condition on bus. A second 's' character (anywhere in string) before 'p' character will cause a repeated Start condition.</li>
<li><b>rNN</b>: Read from bus, where NN is two upper case hex characters stating how many bytes to read.</li>
</ul>
<p>This method of writing I2C messages is particularly well suited for writing messages that contain text strings. For example, to write a string to a "LCD2S Serial I2C Display", the following code can be used: </p>
<div class="fragment"><div class="line"><span class="comment">//Write to LCD2S at address 0x50, 0x80=Write Text command, 0x0C=Clear Screen command, 0x0A=Go to next line command</span></div>
<div class="line"><a class="code" href="nz__ser_i2_c_8h.html#a733cb0297e0660d0de078727ef4e9ccb">i2c1WriteAsciiEscString</a>(<span class="stringliteral">&quot;50800C&#39;Hello&#39;0A&#39;World&#39;&quot;</span>);</div>
</div><!-- fragment --><p>For additional examples, see <a href="http://www.netcruzer.com/examples-i2c">examples on netcruzer.com</a>.</p>
<h2><a class="anchor" id="nz_seri2c_read"></a>
Reading from the I2C Port</h2>
<p>When reading data from an I2C device, the data will be read in the background via the I2C interrupts. The destination of the read data is determined by the read functions used:</p>
<ul>
<li>Using the <a class="el" href="nz__ser_i2_c_8h.html#a878e5b523bca8de8ff279e5e52ffdefd">i2c1Read()</a> function, the read data will be placed in the default Circular Receive Buffer. It is retrieved by using the <a class="el" href="nz__ser_i2_c_8h.html#aba306a7bfa2de83e2a8b06a496c98390">i2c1GetByte()</a> or <a class="el" href="nz__ser_i2_c_8h.html#abeefd804df3eef1d6cecb7f970a5c993">i2c1GetArray()</a> functions.</li>
<li>Using the <a class="el" href="nz__ser_i2_c_8h.html#a67af295d4bae009c272a04d5f8bc7e8b">i2c1ReadToArray()</a> function, the read data will be placed in the buffer passed to this function.</li>
</ul>
<p>The <a class="el" href="nz__ser_i2_c_8h.html#a812b3449c5efa840cb18a7bd8b0605ba">i2c1IsBusy()</a> or <a class="el" href="nz__ser_i2_c_8h.html#adff1d8be3fd82042a75648cfb717e79f">i2c1GetStatusWait()</a> functions can be used to check when the background transmission has finished (and if successful), and the read data is available.</p>
<p>The following example show how to use <a class="el" href="nz__ser_i2_c_8h.html#a878e5b523bca8de8ff279e5e52ffdefd">i2c1Read()</a> to read data: </p>
<div class="fragment"><div class="line">BYTE c;</div>
<div class="line"><a class="code" href="nz__ser_i2_c_8h.html#abf5d624c9e75d28fd11b587caa239a34">i2c1BeginTransmission</a>(0x50);    <span class="comment">//Start transmission to slave at address 0x50</span></div>
<div class="line"><a class="code" href="nz__ser_i2_c_8h.html#a296d883d2efc94de4b2b473a1580bdde">i2c1Write</a>(0xD0);                <span class="comment">//Write 0xD0 = address of register to read</span></div>
<div class="line"><a class="code" href="nz__ser_i2_c_8h.html#a878e5b523bca8de8ff279e5e52ffdefd">i2c1Read</a>(10);                   <span class="comment">//Read 10 byte.</span></div>
<div class="line"><a class="code" href="nz__ser_i2_c_8h.html#a3476629591dc4ab13522243cec246686">i2c1EndTransmission</a>();          <span class="comment">//End transmission, and start sending message in background</span></div>
<div class="line"><span class="comment">//Wait till transmission finished (background via interrupt), and check if successful</span></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="nz__ser_i2_c_8h.html#adff1d8be3fd82042a75648cfb717e79f">i2c1GetStatusWait</a>(0)==0) {</div>
<div class="line">    <span class="comment">//Get all available data from default Receive Circular Buffer (might be less than requested!).</span></div>
<div class="line">    <span class="keywordflow">while</span> (<a class="code" href="nz__ser_i2_c_8h.html#a64bfb0e270835ce16542d3cad361c9fd">i2c1HasData</a>()) {</div>
<div class="line">        c = <a class="code" href="nz__ser_i2_c_8h.html#aba306a7bfa2de83e2a8b06a496c98390">i2c1GetByte</a>();      <span class="comment">//Get next available byte</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The following example show how to use <a class="el" href="nz__ser_i2_c_8h.html#a67af295d4bae009c272a04d5f8bc7e8b">i2c1ReadToArray()</a> to read data to a BYTE array: </p>
<div class="fragment"><div class="line">BYTE buf[2];</div>
<div class="line"><a class="code" href="nz__ser_i2_c_8h.html#abf5d624c9e75d28fd11b587caa239a34">i2c1BeginTransmission</a>(0x50);    <span class="comment">//Start transmission to slave at address 0x50</span></div>
<div class="line"><a class="code" href="nz__ser_i2_c_8h.html#a296d883d2efc94de4b2b473a1580bdde">i2c1Write</a>(0xD0);                <span class="comment">//Write 0xD0 = address of register to read</span></div>
<div class="line"><a class="code" href="nz__ser_i2_c_8h.html#a67af295d4bae009c272a04d5f8bc7e8b">i2c1ReadToArray</a>(buf, 2);        <span class="comment">//Read 2 bytes to buf</span></div>
<div class="line"><a class="code" href="nz__ser_i2_c_8h.html#a3476629591dc4ab13522243cec246686">i2c1EndTransmission</a>();          <span class="comment">//End transmission, and start sending message in background</span></div>
<div class="line"><span class="comment">//Wait till transmission finished (background via interrupt), and get status</span></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="nz__ser_i2_c_8h.html#adff1d8be3fd82042a75648cfb717e79f">i2c1GetStatusWait</a>(0)==0) {</div>
<div class="line">    <span class="comment">//Message Successful. Read data available in buf[0] and buf[1].</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>The <a class="el" href="nz__i2c1_8h.html#a563c226bf741e2c3c7a7385a5d3278b0">i2c1ReadSlaveReg()</a> function replaces the code shown above with a single function. </p>
<div class="fragment"><div class="line">BYTE buf[2];</div>
<div class="line"><span class="comment">//Read 2 bytes from register 0x0D of slave at address 0x50, and save result in &quot;buf&quot; array</span></div>
<div class="line"><a class="code" href="nz__i2c1_8h.html#a563c226bf741e2c3c7a7385a5d3278b0">i2c1ReadSlaveReg</a>(0x50, 0x0D, buf, 2);</div>
<div class="line"><span class="comment">//Wait till transmission finished (background via interrupt), and get status</span></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="nz__ser_i2_c_8h.html#adff1d8be3fd82042a75648cfb717e79f">i2c1GetStatusWait</a>(0)==0) {</div>
<div class="line">    <span class="comment">//Message Successful. Read data available in buf[0] and buf[1].</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Each I2C device actually has two addresses. The even address is used to write to it, and the odd address to read from it. Bit 0 (R/W bit) of the address byte is used to determine if a read or write command has to be executed. If 1, a I2C read is executed. To read, set bit 0 of the address. For example, accessing address 0x20 will write to the node, and address 0x21 will read from it.</p>
<h2><a class="anchor" id="nz_seri2c_status"></a>
Status of I2C Transmission</h2>
<p>The status of an I2C transmission can be obtained by a couple of different methods.</p>
<p><b>Method 1 (pre transmission status):</b><br/>
 The functions for adding data to the I2C Transmit Queue (Circular Buffer) all return 0 if successful. If any of them return a non-zero value, the Transmit Queue if probably full. At this stage the message has NOT been sent on the bus yet, so no bus error messages will be returned (slave not responding with ACK for example). These functions include:<br/>
 <a class="el" href="nz__ser_i2_c_8h.html#abf5d624c9e75d28fd11b587caa239a34">i2c1BeginTransmission()</a>, <a class="el" href="nz__ser_i2_c_8h.html#a296d883d2efc94de4b2b473a1580bdde">i2c1Write()</a>, <a class="el" href="nz__ser_i2_c_8h.html#ab35b527e048749ac5e45752c2a88aadd">i2c1WriteString()</a>, <a class="el" href="nz__ser_i2_c_8h.html#a3476629591dc4ab13522243cec246686">i2c1EndTransmission()</a>....<br/>
 To save checking the returned value of each function, only the value returned by <a class="el" href="nz__ser_i2_c_8h.html#a3476629591dc4ab13522243cec246686">i2c1EndTransmission()</a> can be checked, for example: </p>
<div class="fragment"><div class="line"><a class="code" href="nz__ser_i2_c_8h.html#abf5d624c9e75d28fd11b587caa239a34">i2c1BeginTransmission</a>(0x50);    <span class="comment">//Start transmission to slave at address 0x50</span></div>
<div class="line"><a class="code" href="nz__ser_i2_c_8h.html#a296d883d2efc94de4b2b473a1580bdde">i2c1Write</a>(0xD0);                <span class="comment">//Write 0xD0</span></div>
<div class="line"><span class="comment">//End transmission, and start sending message in background. Returns 0 if ERROR!</span></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="nz__ser_i2_c_8h.html#a3476629591dc4ab13522243cec246686">i2c1EndTransmission</a>()!=0) {</div>
<div class="line">    <span class="comment">//Message Successfully added to transmit Queue.</span></div>
<div class="line">}</div>
</div><!-- fragment --><p> Using this method of error checking does NOT detect if there is no slave on the bus with the given address. It however has <b>the advantage</b> of not having to wait for the transmission to finish!</p>
<p><b>Method 2 (post transmission status):</b><br/>
 If additional status information is required, the code has to wait till the transmission is finished(is done in the background via I2C interrupts). Once finished, the <a class="el" href="nz__ser_i2_c_8h.html#a4c01eb5e90a96dcf72718930771e795e">i2c1GetStatus()</a> function can be used to get the status of the transmission. The <a class="el" href="nz__ser_i2_c_8h.html#adff1d8be3fd82042a75648cfb717e79f">i2c1GetStatusWait()</a> function will wait till finished, and then return the status. For example: </p>
<div class="fragment"><div class="line"><a class="code" href="nz__ser_i2_c_8h.html#abf5d624c9e75d28fd11b587caa239a34">i2c1BeginTransmission</a>(0x50);    <span class="comment">//Start transmission to slave at address 0x50</span></div>
<div class="line"><a class="code" href="nz__ser_i2_c_8h.html#a296d883d2efc94de4b2b473a1580bdde">i2c1Write</a>(0xD0);                <span class="comment">//Write 0xD0</span></div>
<div class="line"><a class="code" href="nz__ser_i2_c_8h.html#a3476629591dc4ab13522243cec246686">i2c1EndTransmission</a>();          <span class="comment">//End transmission, and start sending message in background</span></div>
<div class="line"><span class="comment">//Wait till transmission finished (background via interrupt), and check if successful</span></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="nz__ser_i2_c_8h.html#adff1d8be3fd82042a75648cfb717e79f">i2c1GetStatusWait</a>(0)==0) {</div>
<div class="line">    <span class="comment">//Message Successfully added to transmit Queue, and sent to slave!</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>The status of the last 4 transmissions are stored, and can be requested by passing the address of the slave in the "adr" parameter of the <a class="el" href="nz__ser_i2_c_8h.html#a4c01eb5e90a96dcf72718930771e795e">i2c1GetStatus()</a> function. Passing 0 to this function will return the status of the last transmission. This function is usefull when sending an I2C message, and checking the status at a later stage. If other tasks also send I2C messages to other slaves, this function can be used to be sure to get the status of the desired message.</p>
<h2><a class="anchor" id="nz_seri2c_port_independent"></a>
Port Independent I2C Functions</h2>
<p>In stead of using the normal port specific i2c1Xxx(), i2c2Xxx() and i2c3Xxx() functions, the port independent i2cXxx() versions can be used. The same functions are available, but each has an additional parameter specifying the port to use. The first parameter of each function is a pointer to the I2C_INFO structure for the desired I2C port. The I2C1_INFO, I2C2_INFO and I2C3_INFO defines can be used. These functions can be used to <b>optimize performance</b>, seeing that they are a bit more efficient than the port specific versions. Internally, the port specific function call the port indepenent functions.</p>
<p>For example, the <a class="el" href="nz__ser_i2_c_8h.html#ac0b28a0c0b08b3ce920b80289106adec">i2cWrite()</a> function is the port independent version of the <a class="el" href="nz__ser_i2_c_8h.html#a296d883d2efc94de4b2b473a1580bdde">i2c1Write()</a> function. Using the normal function to write 100 to I2C bus 1 looks like this: </p>
<div class="fragment"><div class="line"><a class="code" href="nz__ser_i2_c_8h.html#a296d883d2efc94de4b2b473a1580bdde">i2c1Write</a>(100);</div>
</div><!-- fragment --><p>Using port independent functions look like this: </p>
<div class="fragment"><div class="line"><a class="code" href="nz__ser_i2_c_8h.html#ac0b28a0c0b08b3ce920b80289106adec">i2cWrite</a>(I2C1_INFO, 100);</div>
</div><!-- fragment --><p> or </p>
<div class="fragment"><div class="line"><a class="code" href="struct_i2_c___i_n_f_o__.html">I2C_INFO</a>* objI2C = I2C1_INFO;</div>
<div class="line"><a class="code" href="nz__ser_i2_c_8h.html#ac0b28a0c0b08b3ce920b80289106adec">i2cWrite</a>(objI2C, 100);</div>
</div><!-- fragment --><h1><a class="anchor" id="nz_seri2c_cirbuf"></a>
Advanced - Using Circular Buffers</h1>
<p>Internally <a class="el" href="nz__circular_buffer_8h.html#nz_circularBuffer_desc">Circular Buffers</a> are used for queueing transmit data, and storing received data. In stead of using the normal i2cXxx functions (like i2cBeginTransmisstion(), <a class="el" href="nz__ser_i2_c_8h.html#ac0b28a0c0b08b3ce920b80289106adec">i2cWrite()</a>...), data can be directly written to, and read from the Circular Buffer. The buffers are configured as <a class="el" href="nz__circular_buffer_8h.html#nz_circularBuffer_format_bin_esc">Binary Format, with Escape Sequence</a>. This means special "escape sequences"(control characters) are contained in the buffer, along with the normal data. See <a class="el" href="nz__circular_buffer_8h.html#nz_circularBuffer_format_bin_esc">Binary Format, with Escape Sequence</a> for details.</p>
<p>The CIRBUF_TX_I2Cn and CIRBUF_RX_I2Cn constants (where n is port number) can be used with the Circular Buffer functions to address the required transmit or receive I2C buffers. For example, to write a byte to I2C port 1's transmit buffer: </p>
<div class="fragment"><div class="line"><a class="code" href="nz__circular_buffer_8h.html#ad56769cd53384959977771c1f1fe3529">cbufPutByte</a>(CIRBUF_TX_I2C1, 0x6A);</div>
</div><!-- fragment --><p>To send a message via the I2C port, it is written to the I2C transmit buffer. This buffer is processed in the background, and all data added to it is send via the I2S port. Special "escape sequences" (control characters) are used for putting Start, Stop and Repeated Start conditions on the bus. The '^' is the default "escape character". The "escape sequences" are:</p>
<table class="doxtable">
<tr>
<th>Escape<br/>
 Sequence </th><th>Description  </th></tr>
<tr>
<td><b>^^</b> </td><td>Will cause a single <b>'^'</b> character to be sent on the I2C port </td></tr>
<tr>
<td><b>^s</b> </td><td>Put START on bus. A second 's' control character (anywhere in string) before a 'p' control character will cause a REPEATED START condition. </td></tr>
<tr>
<td><b>^p</b> </td><td>Put STOP on bus </td></tr>
<tr>
<td><b>^rn</b> </td><td>Read <b>'n'</b> number of bytes(n=0-254). A value of 255 means read till slave does not ACK. Read bytes are written to receive circular buffer. </td></tr>
<tr>
<td><b>^rn^ua</b> </td><td>Same as <b>'^rn'</b>, but writes read bytes to given address in "User Memory", where <b>'a'</b> is a value from 0 to 255. </td></tr>
</table>
<p>For the '<b>^s</b>' Escape Sequence (Start), the next byte in the buffer MUST be the slave address! Even addresses are used to write to the slave, and odd addresses to read from them.</p>
<ul>
<li>The address must be an <b>even</b> number when writing data to the slave. For example:<br/>
 ^,s,50,10,5A,^,p = START, 0x50 address, write 0x10, write 0x5A, STOP.</li>
<li>The address must be an <b>odd</b> number when reading data from a slave. A START with odd number address MUST be followed by the '<b>^r</b>'(Read) Escape Sequence - see description below!</li>
</ul>
<p>For the '<b>^r</b>' Escape Sequence (Read), the next byte in the buffer MUST be the number of bytes to read! It can only be used inside a message with START and STOP conditions.</p>
<ul>
<li>When '<b>^r</b>' is positioned <b>after</b> written bytes, it will cause a <b>REPEATED START</b> condition. In this case, the address used for the START is reused, with the "R/W" bit set to 1. For example:<br/>
 ^,s,50,10,^,r,02,^,p = START, 0x50 address, write 0x10, REPEATED START, 0x51 address, read 2 bytes, STOP.</li>
<li>When '<b>^r</b>' is positioned at the <b>beginning</b> of the message, directly after the START and slave address, no REPEATED START will be sent. For this case, the address following the START MUST be odd, meaning the "R/W" bit is set, indicating a read to follow! For example:<br/>
 ^,s,51,^,r,02,^,p = START, 0x51 address, read 2 bytes, STOP.<br/>
 As a shorthand, the '<b>^r</b>' Escape Sequence (Read) can be omitted, and the number of bytes to read directly given. For example:<br/>
 ^,s,51,02,^,p = START, 0x51 address, read 2 bytes, STOP.</li>
</ul>
<h2><a class="anchor" id="nz_seri2c_cirbuf_examples"></a>
Examples</h2>
<p>Following are some examples for using Circular Buffers for I2C Communication.</p>
<div class="fragment"><div class="line"><a class="code" href="nz__circular_buffer_8h.html#a5ec513956e1e3c33e29ec996ae9c9134">cbufPutControlChar</a>(CIRBUF_TX_I2C1, <span class="charliteral">&#39;s&#39;</span>);    <span class="comment">//I2C Start - use &#39;s&#39; control character</span></div>
<div class="line"><a class="code" href="nz__circular_buffer_8h.html#ad56769cd53384959977771c1f1fe3529">cbufPutByte</a>(CIRBUF_TX_I2C1, 0x6A);          <span class="comment">//I2C address - MUST follow I2C Start</span></div>
<div class="line"><a class="code" href="nz__circular_buffer_8h.html#ad56769cd53384959977771c1f1fe3529">cbufPutByte</a>(CIRBUF_TX_I2C1, 0x52);          <span class="comment">//Data</span></div>
<div class="line"><a class="code" href="nz__circular_buffer_8h.html#a5ec513956e1e3c33e29ec996ae9c9134">cbufPutControlChar</a>(CIRBUF_TX_I2C1, <span class="charliteral">&#39;p&#39;</span>);    <span class="comment">//I2C Stop - use &#39;p&#39; control character</span></div>
</div><!-- fragment --><p> Writes 0x52 to an I2C device with address 6A, via I2C port 1. The following characters will be added to the buffer<br/>
 '<b>^</b>', '<b>s</b>', <b>0x5A</b>, <b>0x52</b>, '<b>^</b>', '<b>p</b>'</p>
<div class="fragment"><div class="line"><a class="code" href="nz__circular_buffer_8h.html#a5ec513956e1e3c33e29ec996ae9c9134">cbufPutControlChar</a>(CIRBUF_TX_I2C1, <span class="charliteral">&#39;s&#39;</span>);    <span class="comment">//I2C Start - use &#39;s&#39; control character</span></div>
<div class="line"><a class="code" href="nz__circular_buffer_8h.html#ad56769cd53384959977771c1f1fe3529">cbufPutByte</a>(CIRBUF_TX_I2C1, 0x50);          <span class="comment">//I2C address - MUST follow I2C Start</span></div>
<div class="line"><a class="code" href="nz__circular_buffer_8h.html#aaf805c529e964381d5c1d5e8e98e893d">cbufPutString</a>(CIRBUF_TX_I2C1, <span class="stringliteral">&quot;Hello&quot;</span>);     <span class="comment">//Data</span></div>
<div class="line"><a class="code" href="nz__circular_buffer_8h.html#a5ec513956e1e3c33e29ec996ae9c9134">cbufPutControlChar</a>(CIRBUF_TX_I2C1, <span class="charliteral">&#39;p&#39;</span>);    <span class="comment">//I2C Stop - use &#39;p&#39; control character</span></div>
</div><!-- fragment --><p> Writes "Hello" to an I2C device with address 50, via I2C port 2. The following characters will be added to the buffer<br/>
 '<b>^</b>', '<b>s</b>', <b>0x50</b>, '<b>H</b>', '<b>e</b>', '<b>l</b>', '<b>l</b>', '<b>o</b>', '<b>^</b>', '<b>p</b>'</p>
<h1><a class="anchor" id="nz_seri2c_ascii"></a>
Advanced - Using ASCII Commands</h1>
<p>As described in <a class="el" href="group__nz__seri2c__details.html#nz_seri2c_cirbuf">the previous section</a>, Circular Buffers (configured as Binary Format, with Escape Sequence) are used for writing and reading data. It describes how to write and read binary data to the Circular Buffers. As an alternative, this same data can be written and read in ASCII format using the <a class="el" href="nz__circular_buffer_8h.html#a7364bd37a4e83828296b92902eb7de68">cbufPutAsciiEscString()</a> function. This function will decode the given ASCII format to the "Binary Format, with Escape Sequence" format of the buffer. See <a class="el" href="nz__circular_buffer_8h.html#nz_circularBuffer_format_ascii_esc">ASCII Format, with Escape Sequence</a> for details on the format of the ASCII string.</p>
<p>In short, the ASCII string uses 2 upper case characters to represent a single hex character. Strings must be enclosed within single quotation marks('). Lower case characters 'a' to 'z' are used to represent "Control characters".</p>
<h2><a class="anchor" id="nz_seri2c_ascii_examples"></a>
Examples</h2>
<p>Following are some examples for using ASCII commands for communicating I2C devices.</p>
<p>Writing 0x52 to an I2C device with address 6A, via I2C port 1<br/>
 </p>
<div class="fragment"><div class="line"><a class="code" href="nz__circular_buffer_8h.html#a7364bd37a4e83828296b92902eb7de68">cbufPutAsciiEscString</a>(CIRBUF_TX_I2C1, 0, <span class="stringliteral">&quot;s6A52p&quot;</span>);    <span class="comment">//Start, Address 0x6A, Data 0x52, Stop</span></div>
</div><!-- fragment --><p> The following characters will be added to the buffer<br/>
 '<b>^</b>', '<b>s</b>', <b>0x6A</b>, <b>0x52</b>, '<b>^</b>', '<b>p</b>'</p>
<p>Writing "Hello" to an I2C device with address 50, via I2C port 2<br/>
 </p>
<div class="fragment"><div class="line"><a class="code" href="nz__circular_buffer_8h.html#a7364bd37a4e83828296b92902eb7de68">cbufPutAsciiEscString</a>(CIRBUF_TX_I2C1, 0, <span class="stringliteral">&quot;s50&#39;Hello&#39;p&quot;</span>);   <span class="comment">//Start, Address 0x50, String &quot;Hello&quot;, Stop</span></div>
</div><!-- fragment --><p> The following characters will be added to the buffer<br/>
 '<b>^</b>', '<b>s</b>', <b>0x50</b>, '<b>H</b>', '<b>e</b>', '<b>l</b>', '<b>l</b>', '<b>o</b>', '<b>^</b>', '<b>p</b>' </p>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Jan 15 2014 10:30:14 for Netcruzer Library API by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.4 </li>
  </ul>
</div>
</body>
</html>
