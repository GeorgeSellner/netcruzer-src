<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>Netcruzer Library API: netcruzer/lib/nz_helpersCx.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Netcruzer Library API
   &#160;<span id="projectnumber">V2.03</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('nz__helpers_cx_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">nz_helpersCx.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Netcruzer Advanced Helper Functions, means to internal use.  
<a href="#details">More...</a></p>

<p><a href="nz__helpers_cx_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a018e4c677eeac529bd3acf2cbe325274"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>nzWordSwapBytes_ASM_R</b>(W)</td></tr>
<tr class="separator:a018e4c677eeac529bd3acf2cbe325274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42dcc2a8f98b143002060c2f82d3976c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__helpers_cx_8h.html#a42dcc2a8f98b143002060c2f82d3976c">nzWordBitToggle</a>(w, bitPosition)&#160;&#160;&#160;__builtin_btg(w,bitPosition)</td></tr>
<tr class="separator:a42dcc2a8f98b143002060c2f82d3976c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc64cc5f5837347ab52a081c65763b16"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>nzByteSwapNibble_ASM_R</b>(W)</td></tr>
<tr class="separator:adc64cc5f5837347ab52a081c65763b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b0f048019e7b1b9aaaa95dd7af782a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__helpers_cx_8h.html#a43b0f048019e7b1b9aaaa95dd7af782a">nzWordPosOfFirstMsbBit_ASM</a>(W, WPos)</td></tr>
<tr class="separator:a43b0f048019e7b1b9aaaa95dd7af782a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab00dd78a46e3bc91a23d0ecc5349f776"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__helpers_cx_8h.html#ab00dd78a46e3bc91a23d0ecc5349f776">nzWordPosOfFirstLsbBit_ASM</a>(W, WPos)</td></tr>
<tr class="separator:ab00dd78a46e3bc91a23d0ecc5349f776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83ee3b837629327c0f61966a76e3b40c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__helpers_cx_8h.html#a83ee3b837629327c0f61966a76e3b40c">nzWordPosOfFirstChangeMsb</a>(value)&#160;&#160;&#160;__builtin_fbcl(value);</td></tr>
<tr class="separator:a83ee3b837629327c0f61966a76e3b40c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4b2c21ffd7eb6dc98cd276d5665c4dd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>nzWordShiftLefs_ASM</b>(W, Number)</td></tr>
<tr class="separator:af4b2c21ffd7eb6dc98cd276d5665c4dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37fedb52e4562fe6f0204979d3daf9dc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>nzWordShiftRight_ASM</b>(W, Number)</td></tr>
<tr class="separator:a37fedb52e4562fe6f0204979d3daf9dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24851d0a1d212dc73e05a89631cf8174"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__helpers_cx_8h.html#a24851d0a1d212dc73e05a89631cf8174">nzMemSet_ASM_RRR</a>(adr, c, count)</td></tr>
<tr class="separator:a24851d0a1d212dc73e05a89631cf8174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84f2005b16d67bae7016b374ae829e8c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__helpers_cx_8h.html#a84f2005b16d67bae7016b374ae829e8c">nzMemCpy_ASM_RRR</a>(pDst, pSrc, countReg)</td></tr>
<tr class="separator:a84f2005b16d67bae7016b374ae829e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bbd30ed53502053fd33d5cd7fbd20cf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__helpers_cx_8h.html#a9bbd30ed53502053fd33d5cd7fbd20cf">nzMemCpy2_ASM_RRR</a>(pDst, pSrc, countReg)</td></tr>
<tr class="separator:a9bbd30ed53502053fd33d5cd7fbd20cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88fc5823db60c437284848db9b2886e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__helpers_cx_8h.html#ae88fc5823db60c437284848db9b2886e">nzMemCpyDec_ASM_RRR</a>(pDst, pSrc, countReg)</td></tr>
<tr class="separator:ae88fc5823db60c437284848db9b2886e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a78548c16a94c8bb3cb4a418f1dd23"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__helpers_cx_8h.html#a91a78548c16a94c8bb3cb4a418f1dd23">nzMemCpyDec2_ASM_RRR</a>(pDst, pSrc, countReg)</td></tr>
<tr class="separator:a91a78548c16a94c8bb3cb4a418f1dd23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78dae19b0ab57580a9e129ee0e4d69bc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__helpers_cx_8h.html#a78dae19b0ab57580a9e129ee0e4d69bc">nzMemCpyDecNoOut_ASM_RRR</a>(pDst, pSrc, countReg)</td></tr>
<tr class="separator:a78dae19b0ab57580a9e129ee0e4d69bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b794423f5621b38da1213b611f74b9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__helpers_cx_8h.html#a38b794423f5621b38da1213b611f74b9">nzMemCpy_ASM_RRC</a>(pDst, pSrc, count)</td></tr>
<tr class="separator:a38b794423f5621b38da1213b611f74b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6611bf9751f451253b9fe7dfa6ea363"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__helpers_cx_8h.html#ab6611bf9751f451253b9fe7dfa6ea363">nzMemCpyDec_ASM_RRC</a>(pDst, pSrc, count)</td></tr>
<tr class="separator:ab6611bf9751f451253b9fe7dfa6ea363"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af84f37d851f3474e906741b7fc04a975"><td class="memItemLeft" align="right" valign="top">BYTE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__helpers_cx_8h.html#af84f37d851f3474e906741b7fc04a975">nzBytePosOfFirstClearedMsbBit</a> (BYTE b)</td></tr>
<tr class="separator:af84f37d851f3474e906741b7fc04a975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcadea3213d145ee042593813ba19130"><td class="memItemLeft" align="right" valign="top">BYTE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__helpers_cx_8h.html#abcadea3213d145ee042593813ba19130">nzBytePosOfFirstClearedLsbBit</a> (BYTE b)</td></tr>
<tr class="separator:abcadea3213d145ee042593813ba19130"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Netcruzer Advanced Helper Functions, means to internal use. </p>
<dl class="section author"><dt>Author</dt><dd><a href="www.modtronix.com">Modtronix Engineering</a> </dd></dl>
<dl class="section user"><dt>Compiler:</dt><dd>MPLAB XC16 compiler</dd></dl>
<h1><a class="anchor" id="nz_helpersCx_desc"></a>
Description</h1>
<p>This module contains code for implementing a variable size circular buffers. The size can be configured at run time. It is not limited to a power of 2 value.</p>
<h2><a class="anchor" id="nz_helpersCx_conf"></a>
Configuration</h2>
<p>The following defines are used to configure this module, and should be placed in projdefs.h. Note that all items marked [-DEFAULT-] are defaults, and do not have to be placed in projdefs.h if they contain desired configuration! For details, see <a class="el" href="group__info__conf__proj.html">Project Configuration</a>. </p>
<div class="fragment"><div class="line"><span class="comment">// *********************************************************************</span></div>
<div class="line"><span class="comment">// ----------- Netcruzer Helper Configuration (nz_helpersCx.h) -----------</span></div>
<div class="line"><span class="comment">// *********************************************************************</span></div>
</div><!-- fragment --><h1><a class="anchor" id="nz_helpersCx_lic"></a>
Software License Agreement</h1>
<p>The software supplied herewith is owned by Modtronix Engineering, and is protected under applicable copyright laws. The software supplied herewith is intended and supplied to you, the Company customer, for use solely and exclusively on products manufactured by Modtronix Engineering. The code may be modified and can be used free of charge for commercial and non commercial applications. All rights are reserved. Any use in violation of the foregoing restrictions may subject the user to criminal sanctions under applicable laws, as well as to civil liability for the breach of the terms and conditions of this license.</p>
<p>THIS SOFTWARE IS PROVIDED IN AN 'AS IS' CONDITION. NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.</p>
<p>File History</p>
<p>2010-11-24, David H. (DH):</p>
<ul>
<li>Initial version </li>
</ul>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="adc64cc5f5837347ab52a081c65763b16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define nzByteSwapNibble_ASM_R</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">W)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{ <span class="keyword">asm</span>(<span class="stringliteral">&quot;SWAP.b %0&quot;</span>                   \</div>
<div class="line">        : <span class="stringliteral">&quot;+r&quot;</span>(W) <span class="comment">/*outputs*/</span>); }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9bbd30ed53502053fd33d5cd7fbd20cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define nzMemCpy2_ASM_RRR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pDst, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pSrc, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">countReg&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{ <span class="keyword">asm</span> <span class="keyword">volatile</span> ( <span class="stringliteral">&quot;MOV %2,w0 \n DEC w0,w0 \n REPEAT w0 \n MOV.B [%1++],[%0++]&quot;</span>       \</div>
<div class="line">            : <span class="stringliteral">&quot;+d&quot;</span> (pDst), <span class="stringliteral">&quot;+d&quot;</span> (pSrc)  <span class="comment">/* outputs, + = input/outputs */</span>                \</div>
<div class="line">            : <span class="stringliteral">&quot;r&quot;</span> (countReg) <span class="comment">/* inputs (can be &quot;r&quot;, is copied to a W reg by MOV)  */</span>    \</div>
<div class="line">            : <span class="stringliteral">&quot;w0&quot;</span>, <span class="stringliteral">&quot;cc&quot;</span> ); }</div>
</div><!-- fragment --><p>Alternative version for nzMemCpy_ASM_RRR. The "countReg" input does not get modified in this version! </p>

</div>
</div>
<a class="anchor" id="a38b794423f5621b38da1213b611f74b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define nzMemCpy_ASM_RRC</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pDst, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pSrc, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">count&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{ <span class="keyword">asm</span>( <span class="stringliteral">&quot;REPEAT #(%2-1) \n MOV.B [%1++],[%0++]&quot;</span>      \</div>
<div class="line">            :                                           \</div>
<div class="line">            : <span class="stringliteral">&quot;r&quot;</span> (pDst), <span class="stringliteral">&quot;r&quot;</span> (pSrc), <span class="stringliteral">&quot;i&quot;</span> (count) ); }</div>
</div><!-- fragment --><p>Copy src array to destination array, countReg times, using ASM code. Parameters have to be (RRC): REGISTER (pDst), REGISTER (pSrc), CONSTANT (countReg)</p>
<p><br/>
!!! IMPORTANT !!!</p>
<ul>
<li>Ensure countReg IS NOT 0</li>
<li>Ensure countReg is a WORD (or cast to a WORD)</li>
</ul>
<p>When returning, pDst and pScr will both BE INCREMENTED countReg times !!! If this is not required, use the <a class="el" href="nz__helpers_8h.html#ae03752b0dd9b559adc2da978ef7c0e06">nzMemCpy()</a> function. The XC16 compiler seems to ALWAYS increment pDst and pSrc, even if temporary variables are created and passed to pDst and pSrc. If this is done, the compiler optimization ignores these temporary variables, and still increments pSrc and pDst.</p>
<p>So, remember:</p>
<ul>
<li>Only use this macro if pSrc and pDst should be incremented!</li>
<li>Ensure countReg is a WORD, or cast to word. If countReg is a BYTE, this function can go very badly wrong!</li>
<li>Use <a class="el" href="nz__helpers_8h.html#ae03752b0dd9b559adc2da978ef7c0e06">nzMemCpy()</a> function if 0 checking of countReg is required.</li>
<li>When returning, pDst and pScr will both BE INCREMENTED countReg times!</li>
</ul>
<p>! NOTE on compiler optimization ! If after this macro the pDst and pSrc variables are restored to their original values, it seems like the XC16 compiler IGNORES it (optimization on). It assumes these bytes still have their original values, and ignores this code!</p>
<p>Example<br/>
 </p>
<div class="fragment"><div class="line">WORD size = 7;</div>
<div class="line">BYTE arr[128];</div>
<div class="line">BYTE arrSrc[128];</div>
<div class="line">BYTE* pArr = arr;</div>
<div class="line">BYTE* pArrSrc = arrSrc;</div>
<div class="line"></div>
<div class="line"><span class="comment">//Ensure all first 2 parameters are of type BYTE*, and size is a constant!</span></div>
<div class="line"><a class="code" href="nz__helpers_cx_8h.html#a38b794423f5621b38da1213b611f74b9">nzMemCpy_ASM_RRC</a>(pArr, pArrSrc, 7);</div>
<div class="line"></div>
<div class="line"><span class="comment">//This is WRONG, ERROR!!! &quot;arr&quot; and &quot;arrScr&quot; are constants (address value)</span></div>
<div class="line"><a class="code" href="nz__helpers_cx_8h.html#a38b794423f5621b38da1213b611f74b9">nzMemCpy_ASM_RRC</a>(arr, arrSrc, 7);</div>
<div class="line"></div>
<div class="line"><span class="comment">//This is WRONG, ERROR!!! &quot;size&quot; must be a constant, NOT a register!</span></div>
<div class="line"><a class="code" href="nz__helpers_cx_8h.html#a38b794423f5621b38da1213b611f74b9">nzMemCpy_ASM_RRC</a>(arr, arrSrc, size);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pDst</td><td>Destination array, must be a BYTE* variable! </td></tr>
    <tr><td class="paramname">pSrc</td><td>Source array, must be a BYTE* variable! </td></tr>
    <tr><td class="paramname">count</td><td>Number of bytes to write, ENSURE IT IS NOT 0! Must be a WORD literal constant! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a84f2005b16d67bae7016b374ae829e8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define nzMemCpy_ASM_RRR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pDst, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pSrc, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">countReg&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{ <span class="keyword">asm</span> <span class="keyword">volatile</span> ( <span class="stringliteral">&quot;DEC %2,%2 \n REPEAT %2 \n MOV.B [%1++],[%0++] \n INC %2,%2&quot;</span>   \</div>
<div class="line">            : <span class="stringliteral">&quot;+d&quot;</span> (pDst), <span class="stringliteral">&quot;+d&quot;</span> (pSrc)  <span class="comment">/* outputs, + = input/outputs */</span>            \</div>
<div class="line">            : <span class="stringliteral">&quot;d&quot;</span> (countReg) <span class="comment">/* inputs (must be &quot;d&quot;, DEC required a W reg) */</span>       \</div>
<div class="line">            : <span class="stringliteral">&quot;cc&quot;</span> ); }</div>
</div><!-- fragment --><p>Copy src array to destination array, countReg times, using ASM code. Parameters have to be (RRR): REGISTER (pDst), REGISTER (pSrc), REGISTER (countReg)</p>
<p><br/>
!!! IMPORTANT !!!</p>
<ul>
<li>Ensure countReg IS NOT 0</li>
<li>Ensure countReg is a WORD (or cast to a WORD)</li>
</ul>
<p>When returning, pDst and pScr will both BE INCREMENTED countReg times !!! If this is not required, use the <a class="el" href="nz__helpers_8h.html#ae03752b0dd9b559adc2da978ef7c0e06">nzMemCpy()</a> function. The XC16 compiler seems to ALWAYS increment pDst and pSrc, even if temporary variables are created and passed to pDst and pSrc. If this is done, the compiler optimization ignores these temporary variables, and still increments pSrc and pDst.</p>
<p>So, remember:</p>
<ul>
<li>Only use this macro if pSrc and pDst should be incremented!</li>
<li>Ensure countReg is a WORD, or cast to word. If countReg is a BYTE, this function can go very badly wrong!</li>
<li>Use <a class="el" href="nz__helpers_8h.html#ae03752b0dd9b559adc2da978ef7c0e06">nzMemCpy()</a> function if 0 checking of countReg is required.</li>
<li>When returning, pDst and pScr will both BE INCREMENTED countReg times!</li>
</ul>
<p>! NOTE on compiler optimization ! If after this macro the pDst and pSrc variables are restored to their original values, it seems like the XC16 compiler IGNORES it (optimization on). It assumes these bytes still have their original values, and ignores this code!</p>
<p>Example<br/>
 </p>
<div class="fragment"><div class="line">WORD size = 7;</div>
<div class="line">BYTE arr[128];</div>
<div class="line">BYTE arrSrc[128];</div>
<div class="line">BYTE* pArr = arr;</div>
<div class="line">BYTE* pArrSrc = arrSrc;</div>
<div class="line"></div>
<div class="line"><span class="comment">//Ensure all first 2 parameters are of type BYTE*, and size is a WORD variable!</span></div>
<div class="line"><a class="code" href="nz__helpers_cx_8h.html#a84f2005b16d67bae7016b374ae829e8c">nzMemCpy_ASM_RRR</a>(pArr, pArrSrc, size);</div>
<div class="line"></div>
<div class="line"><span class="comment">//This is WRONG, ERROR!!! &quot;arr&quot; and &quot;arrScr&quot; are constants (address value)</span></div>
<div class="line"><a class="code" href="nz__helpers_cx_8h.html#a38b794423f5621b38da1213b611f74b9">nzMemCpy_ASM_RRC</a>(arr, arrSrc, 7);</div>
<div class="line"></div>
<div class="line"><span class="comment">//This is WRONG, ERROR!!! &quot;size&quot; must be a register, not a constant!</span></div>
<div class="line"><a class="code" href="nz__helpers_cx_8h.html#a84f2005b16d67bae7016b374ae829e8c">nzMemCpy_ASM_RRR</a>(arr, arrSrc, 7);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pDst</td><td>Destination array, must be a BYTE* variable! </td></tr>
    <tr><td class="paramname">pSrc</td><td>Source array, must be a BYTE* variable! </td></tr>
    <tr><td class="paramname">countReg</td><td>Number of bytes to write, ENSURE IT IS NOT 0! Must be a WORD variable! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a91a78548c16a94c8bb3cb4a418f1dd23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define nzMemCpyDec2_ASM_RRR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pDst, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pSrc, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">countReg&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{ <span class="keyword">asm</span> <span class="keyword">volatile</span> ( <span class="stringliteral">&quot;MOV %2,w0 \n DEC w0,w0 \n REPEAT w0 \n MOV.B [%1--],[%0--]&quot;</span>   \</div>
<div class="line">            : <span class="stringliteral">&quot;+d&quot;</span> (pDst), <span class="stringliteral">&quot;+d&quot;</span> (pSrc)  <span class="comment">/* outputs, + = input/outputs */</span>            \</div>
<div class="line">            : <span class="stringliteral">&quot;r&quot;</span> (countReg) <span class="comment">/* inputs */</span>                                           \</div>
<div class="line">            : <span class="stringliteral">&quot;w0&quot;</span>, <span class="stringliteral">&quot;cc&quot;</span> ); }</div>
</div><!-- fragment --><p>Alternative version for nzMemCpy_ASM_RRR. The "countReg" input does not get modified in this version! </p>

</div>
</div>
<a class="anchor" id="ab6611bf9751f451253b9fe7dfa6ea363"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define nzMemCpyDec_ASM_RRC</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pDst, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pSrc, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">count&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{ <span class="keyword">asm</span> <span class="keyword">volatile</span> ( <span class="stringliteral">&quot;REPEAT #(%2-1) \n MOV.B [%1--],[%0--]&quot;</span>                \</div>
<div class="line">            : <span class="stringliteral">&quot;+r&quot;</span> (pDst), <span class="stringliteral">&quot;+r&quot;</span> (pSrc) <span class="comment">/* outputs, + = input/outputs */</span>     \</div>
<div class="line">            :  <span class="stringliteral">&quot;i&quot;</span> (count) <span class="comment">/* inputs */</span> ); }</div>
</div><!-- fragment --><p>Same as <a class="el" href="nz__helpers_cx_8h.html#a38b794423f5621b38da1213b611f74b9">nzMemCpy_ASM_RRC()</a>, but copies backwards. </p>

</div>
</div>
<a class="anchor" id="ae88fc5823db60c437284848db9b2886e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define nzMemCpyDec_ASM_RRR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pDst, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pSrc, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">countReg&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{ <span class="keyword">asm</span>  ( <span class="stringliteral">&quot;DEC %2,%2 \n REPEAT %2 \n MOV.B [%1--],[%0--] \n INC %2,%2&quot;</span>        \</div>
<div class="line">            : <span class="stringliteral">&quot;+d&quot;</span> (pDst), <span class="stringliteral">&quot;+d&quot;</span> (pSrc)  <span class="comment">/* outputs, + = input/outputs */</span>         \</div>
<div class="line">            : <span class="stringliteral">&quot;d&quot;</span> (countReg) <span class="comment">/* inputs */</span>                                        \</div>
<div class="line">            : <span class="stringliteral">&quot;cc&quot;</span> ); }</div>
</div><!-- fragment --><p>Save as <a class="el" href="nz__helpers_cx_8h.html#a84f2005b16d67bae7016b374ae829e8c">nzMemCpy_ASM_RRR()</a>, but increments pointers backwards.</p>
<p><br/>
!!! IMPORTANT !!!</p>
<ul>
<li>Ensure countReg IS NOT 0</li>
<li>Ensure countReg is a WORD (or cast to a WORD)</li>
</ul>
<p>When returning, pDst and pScr will both BE DECREMENTED countReg times !!! </p>

</div>
</div>
<a class="anchor" id="a78dae19b0ab57580a9e129ee0e4d69bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define nzMemCpyDecNoOut_ASM_RRR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pDst, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pSrc, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">countReg&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{ <span class="keyword">asm</span>  ( <span class="stringliteral">&quot;DEC %2,%2 \n REPEAT %2 \n MOV.B [%1--],[%0--] \n INC %2,%2&quot;</span>   \</div>
<div class="line">            : <span class="comment">/* outputs, + = input/outputs */</span>                              \</div>
<div class="line">            : <span class="stringliteral">&quot;d&quot;</span> (pDst), <span class="stringliteral">&quot;d&quot;</span> (pSrc), <span class="stringliteral">&quot;d&quot;</span> (countReg) <span class="comment">/* inputs */</span>           \</div>
<div class="line">            : <span class="stringliteral">&quot;cc&quot;</span> ); }</div>
</div><!-- fragment --><p>Similar to nzMemCpyDec_ASM_RRR, but NOT garaunteed that pDst and pSrc will be incremented on return (no output). They could be, but should not be relied on!</p>
<p><br/>
!!! IMPORTANT !!!</p>
<ul>
<li>Ensure countReg IS NOT 0</li>
<li>Ensure countReg is a WORD (or cast to a WORD)</li>
</ul>
<p>When returning, pDst and pScr will both BE DECREMENTED countReg times !!! </p>

</div>
</div>
<a class="anchor" id="a24851d0a1d212dc73e05a89631cf8174"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define nzMemSet_ASM_RRR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">adr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">count&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{ <span class="keyword">asm</span>( <span class="stringliteral">&quot;MOV %0,w0 \n REPEAT #(%2-1) \n MOV.B %1,[w0++]&quot;</span>     \</div>
<div class="line">           : <span class="comment">/*no outputs*/</span>                                     \</div>
<div class="line">           : <span class="stringliteral">&quot;r&quot;</span> (adr), <span class="stringliteral">&quot;r&quot;</span> (c), <span class="stringliteral">&quot;i&quot;</span> (count)                    \</div>
<div class="line">           : <span class="stringliteral">&quot;w0&quot;</span>); }</div>
</div><!-- fragment --><p>Sets the given memory with the given byte.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adr</td><td>Destination address of array </td></tr>
    <tr><td class="paramname">c</td><td>Byte to set array to </td></tr>
    <tr><td class="paramname">count</td><td>Number of bytes to write </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a42dcc2a8f98b143002060c2f82d3976c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define nzWordBitToggle</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">w, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bitPosition&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;__builtin_btg(w,bitPosition)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt>Function:</dt><dd>void <a class="el" href="nz__helpers_cx_8h.html#a42dcc2a8f98b143002060c2f82d3976c">nzWordBitToggle(WORD *w, WORD bitPosition)</a></dd></dl>
<p>Toggle bit in word. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>A pointer to the data item for which a bit should be toggled. </td></tr>
    <tr><td class="paramname">bitPosition</td><td>A literal value in the range of 0 to 15. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a83ee3b837629327c0f61966a76e3b40c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define nzWordPosOfFirstChangeMsb</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">value)</td><td></td>
          <td>&#160;&#160;&#160;__builtin_fbcl(value);</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt>Function:</dt><dd>WORD <a class="el" href="nz__helpers_cx_8h.html#a83ee3b837629327c0f61966a76e3b40c">nzWordPosOfFirstChangeMsb(WORD value)</a></dd></dl>
<p>Finds the first bit change from left in value. This is useful for dynamic scaling of fixed-point data. Find the first occurrence of a one (for a positive value), or zero (for a negative value), starting from the Most Significant bit after the sign bit of Ws and working towards the Least Significant bit of the word operand. The bit number result is sign-extended to 16 bits. The next Most Significant bit after the sign bit is allocated bit number 0 and the Least Significant bit is allocated bit number -14. This bit ordering allows for the immediate use of Wd with the SFTAC instruction for scaling values up. If a bit change is not found, a result of -15 is returned and the C flag is set. When a bit change is found, the C flag is cleared.</p>
<p>!!!!! This instruction operates in Word mode only !!!!!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Integer number of first bit change. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the shifted addition result to an accumulator. </dd></dl>

</div>
</div>
<a class="anchor" id="ab00dd78a46e3bc91a23d0ecc5349f776"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define nzWordPosOfFirstLsbBit_ASM</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">W, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">WPos&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{ <span class="keyword">asm</span>( <span class="stringliteral">&quot;FF1R %1,%0&quot;</span>                             \</div>
<div class="line">        : <span class="stringliteral">&quot;=r&quot;</span>(WPos) <span class="comment">/*outputs*/</span>                    \</div>
<div class="line">        : <span class="stringliteral">&quot;r&quot;</span>(W) <span class="comment">/*inputs*/</span> ); }</div>
</div><!-- fragment --><p>Finds the first occurrence of a 1 starting from the Least Significant bit of given WORD, and working towards the Most Significant bit. The bit number result is zero-extended to 16 bits. Bit numbering begins with the Least Significant bit (allocated number 1) and advances to the Most Significant bit (allocated number 16). A result of zero indicates a 1 was not found.</p>
<p>!!!!! This instruction operates in Word mode only !!!!! </p>

</div>
</div>
<a class="anchor" id="a43b0f048019e7b1b9aaaa95dd7af782a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define nzWordPosOfFirstMsbBit_ASM</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">W, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">WPos&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{ <span class="keyword">asm</span>( <span class="stringliteral">&quot;FF1L %1,%0&quot;</span>                             \</div>
<div class="line">        : <span class="stringliteral">&quot;=r&quot;</span>(WPos) <span class="comment">/*outputs*/</span>                    \</div>
<div class="line">        : <span class="stringliteral">&quot;r&quot;</span>(W) <span class="comment">/*inputs*/</span>); }</div>
</div><!-- fragment --><p>Finds the first occurrence of a 1 starting from the Most Significant bit of given WORD, and working towards the Least Significant bit. The bit number result is zero-extended to 16 bits. Bit numbering begins with the Most Significant bit (allocated number 1) and advances to the Least Significant bit (allocated number 16). A result of zero indicates a 1 was not found.</p>
<ul>
<li>!!!!! This instruction operates in Word mode only !!!!! </li>
</ul>

</div>
</div>
<a class="anchor" id="af4b2c21ffd7eb6dc98cd276d5665c4dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define nzWordShiftLefs_ASM</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">W, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Number&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{ <span class="keyword">asm</span>( <span class="stringliteral">&quot;SL %0, #%1, %0&quot;</span>                     \</div>
<div class="line">        : <span class="stringliteral">&quot;+r&quot;</span> (W) <span class="comment">/*outputs*/</span>                  \</div>
<div class="line">        : <span class="stringliteral">&quot;i&quot;</span> (Number) <span class="comment">/*inputs*/</span> ); }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a37fedb52e4562fe6f0204979d3daf9dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define nzWordShiftRight_ASM</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">W, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Number&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{ <span class="keyword">asm</span>( <span class="stringliteral">&quot;SR %0, #%1, %0&quot;</span>                     \</div>
<div class="line">        : <span class="stringliteral">&quot;+r&quot;</span> (W) <span class="comment">/*outputs*/</span>                  \</div>
<div class="line">        : <span class="stringliteral">&quot;i&quot;</span> (Number) <span class="comment">/*inputs*/</span> ); }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a018e4c677eeac529bd3acf2cbe325274"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define nzWordSwapBytes_ASM_R</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">W)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{ <span class="keyword">asm</span>( <span class="stringliteral">&quot;SWAP.w %0&quot;</span>                  \</div>
<div class="line">        : <span class="stringliteral">&quot;+r&quot;</span> (W) <span class="comment">/*outputs*/</span>); }</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="abcadea3213d145ee042593813ba19130"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BYTE nzBytePosOfFirstClearedLsbBit </td>
          <td>(</td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>b</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the first occurrence of a 0 starting from the Least Significant bit of given BYTE, and working towards the Most Significant bit. The bit number result is zero-extended to 8 bits. Bit numbering begins with the Least Significant bit (allocated number 1) and advances to the Most Significant bit (allocated number 8). A result of zero indicates a 0 was not found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>Byte to search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value from 1-8, or 0 if all bit were 1 </dd></dl>

</div>
</div>
<a class="anchor" id="af84f37d851f3474e906741b7fc04a975"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BYTE nzBytePosOfFirstClearedMsbBit </td>
          <td>(</td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>b</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the first occurrence of a 0 starting from the Most Significant bit of given BYTE, and working towards the Least Significant bit. Bit numbering begins with the Most Significant bit (allocated number 8) and advances to the Least Significant bit (allocated number 1). A result of zero indicates a 0 was not found.</p>
<p>!!!!! IMPORTANT !!!!! Note that this function returns 1 for LSB bit, and 8 for LSB. The equavalent WORD function <a class="el" href="nz__helpers_cx_8h.html#a43b0f048019e7b1b9aaaa95dd7af782a">nzWordPosOfFirstMsbBit_ASM()</a> return 1 for MSB (16 for LSB)!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>Byte to search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value from 1-8, or 0 if all bit were 1 </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_0497715779ca99cb1134d5ce544966ba.html">netcruzer</a></li><li class="navelem"><a class="el" href="dir_285a68def6f82363136d1caaa0fe0051.html">lib</a></li><li class="navelem"><a class="el" href="nz__helpers_cx_8h.html">nz_helpersCx.h</a></li>
    <li class="footer">Generated on Tue Dec 9 2014 15:08:19 for Netcruzer Library API by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.4 </li>
  </ul>
</div>
</body>
</html>
