<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>Netcruzer: netcruzer/lib/nz_circularBufferDefs.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Netcruzer
   &#160;<span id="projectnumber">V1.03</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('nz__circular_buffer_defs_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">nz_circularBufferDefs.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains global data for user apps to access system data.  
<a href="#details">More...</a></p>

<p><a href="nz__circular_buffer_defs_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct___c_i_r_b_u_f.html">_CIRBUF</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a7580fd955704af7e52cd60b05434fe72"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_defs_8h.html#a7580fd955704af7e52cd60b05434fe72">BUFTYPE_STREAMING</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a7580fd955704af7e52cd60b05434fe72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81cc30bc033bb2f5f3c5c53e98e05467"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_defs_8h.html#a81cc30bc033bb2f5f3c5c53e98e05467">BUFTYPE_PACKET</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a81cc30bc033bb2f5f3c5c53e98e05467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a7dd9bdc0986eef069ee8b3db97c903"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_defs_8h.html#a8a7dd9bdc0986eef069ee8b3db97c903">BUFTYPE_PACKET_LARGE</a>&#160;&#160;&#160;3</td></tr>
<tr class="separator:a8a7dd9bdc0986eef069ee8b3db97c903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9221a287e697c595025dfb40948593de"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_defs_8h.html#a9221a287e697c595025dfb40948593de">BUFFORMAT_NONE</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a9221a287e697c595025dfb40948593de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee4bec8a4b44ba8159671c328a3cbac"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_defs_8h.html#a5ee4bec8a4b44ba8159671c328a3cbac">BUFFORMAT_ASCII</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a5ee4bec8a4b44ba8159671c328a3cbac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ffa606c2c5349f618ac511fa4623fe5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_defs_8h.html#a1ffa606c2c5349f618ac511fa4623fe5">BUFFORMAT_ASCII_ESC</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:a1ffa606c2c5349f618ac511fa4623fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d9a24e4030ad1a2d8e14a1878d1b9e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_defs_8h.html#af2d9a24e4030ad1a2d8e14a1878d1b9e">BUFFORMAT_BIN</a>&#160;&#160;&#160;3</td></tr>
<tr class="separator:af2d9a24e4030ad1a2d8e14a1878d1b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c886ac5ee84be8805b456298e4f2246"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_defs_8h.html#a0c886ac5ee84be8805b456298e4f2246">BUFFORMAT_BIN_ESC</a>&#160;&#160;&#160;4</td></tr>
<tr class="separator:a0c886ac5ee84be8805b456298e4f2246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada5ee8f8feeb88ff31785bc658ad9c8a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada5ee8f8feeb88ff31785bc658ad9c8a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BUFTYPE_POW2_MASK</b>&#160;&#160;&#160;0x1000</td></tr>
<tr class="separator:ada5ee8f8feeb88ff31785bc658ad9c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe9616eb78b28362e30a24f55a562ad"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_defs_8h.html#a4fe9616eb78b28362e30a24f55a562ad">CIRBUF_FLAGS_STREAM_POW2</a>&#160;&#160;&#160;(BUFTYPE_POW2_MASK | <a class="el" href="nz__circular_buffer_defs_8h.html#a7580fd955704af7e52cd60b05434fe72">BUFTYPE_STREAMING</a>)</td></tr>
<tr class="separator:a4fe9616eb78b28362e30a24f55a562ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc96e081361ba76e59a778c04b0e3bc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afcc96e081361ba76e59a778c04b0e3bc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CIRBUF_FLAGS_PACKET_POW2</b>&#160;&#160;&#160;(BUFTYPE_POW2_MASK | <a class="el" href="nz__circular_buffer_defs_8h.html#a81cc30bc033bb2f5f3c5c53e98e05467">BUFTYPE_PACKET</a>)</td></tr>
<tr class="separator:afcc96e081361ba76e59a778c04b0e3bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac9a6ee72e4dd99765d8e1bfa7d29cf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ac9a6ee72e4dd99765d8e1bfa7d29cf"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CIRBUF_FLAGS_PACKETLARGE_POW2</b>&#160;&#160;&#160;(BUFTYPE_POW2_MASK | <a class="el" href="nz__circular_buffer_defs_8h.html#a8a7dd9bdc0986eef069ee8b3db97c903">BUFTYPE_PACKET_LARGE</a>)</td></tr>
<tr class="separator:a0ac9a6ee72e4dd99765d8e1bfa7d29cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0224ebb86f5a1bfcdfeb57512c361c74"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0224ebb86f5a1bfcdfeb57512c361c74"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BUF_TYPEFRMT_STREAM_BIN</b>&#160;&#160;&#160;((<a class="el" href="nz__circular_buffer_defs_8h.html#af2d9a24e4030ad1a2d8e14a1878d1b9e">BUFFORMAT_BIN</a>&lt;&lt;2) | <a class="el" href="nz__circular_buffer_defs_8h.html#a7580fd955704af7e52cd60b05434fe72">BUFTYPE_STREAMING</a>)</td></tr>
<tr class="separator:a0224ebb86f5a1bfcdfeb57512c361c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad06e5d2fabaa41b243bde0d7b10089e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad06e5d2fabaa41b243bde0d7b10089e0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BUF_TYPEFRMT_STREAM_BINESC</b>&#160;&#160;&#160;((<a class="el" href="nz__circular_buffer_defs_8h.html#a0c886ac5ee84be8805b456298e4f2246">BUFFORMAT_BIN_ESC</a>&lt;&lt;2) | <a class="el" href="nz__circular_buffer_defs_8h.html#a7580fd955704af7e52cd60b05434fe72">BUFTYPE_STREAMING</a>)</td></tr>
<tr class="separator:ad06e5d2fabaa41b243bde0d7b10089e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d0551d06efb7df5197b8a1f475f0ee6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d0551d06efb7df5197b8a1f475f0ee6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BUF_TYPEFRMT_PACKET_BIN</b>&#160;&#160;&#160;((<a class="el" href="nz__circular_buffer_defs_8h.html#af2d9a24e4030ad1a2d8e14a1878d1b9e">BUFFORMAT_BIN</a>&lt;&lt;2) | <a class="el" href="nz__circular_buffer_defs_8h.html#a81cc30bc033bb2f5f3c5c53e98e05467">BUFTYPE_PACKET</a>)</td></tr>
<tr class="separator:a1d0551d06efb7df5197b8a1f475f0ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab03fdd50b08ef305375f70c5eade68f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab03fdd50b08ef305375f70c5eade68f0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BUF_TYPEFRMT_PACKET_BINESC</b>&#160;&#160;&#160;((<a class="el" href="nz__circular_buffer_defs_8h.html#a0c886ac5ee84be8805b456298e4f2246">BUFFORMAT_BIN_ESC</a>&lt;&lt;2) | <a class="el" href="nz__circular_buffer_defs_8h.html#a81cc30bc033bb2f5f3c5c53e98e05467">BUFTYPE_PACKET</a>)</td></tr>
<tr class="separator:ab03fdd50b08ef305375f70c5eade68f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:abe1952d063f6dc2949499653d4ad778c"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct___c_i_r_b_u_f.html">_CIRBUF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a></td></tr>
<tr class="separator:abe1952d063f6dc2949499653d4ad778c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a44197044ef28ff80bbc09834942ae6be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_defs_8h.html#a44197044ef28ff80bbc09834942ae6be">bufEmpty</a> (<a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf)</td></tr>
<tr class="separator:a44197044ef28ff80bbc09834942ae6be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7868f6cfcf7c84ba71ee799dd05194f2"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_defs_8h.html#a7868f6cfcf7c84ba71ee799dd05194f2">bufIsEmpty</a> (<a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf)</td></tr>
<tr class="separator:a7868f6cfcf7c84ba71ee799dd05194f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45df30f7a8af5351fd39aa38c3708854"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_defs_8h.html#a45df30f7a8af5351fd39aa38c3708854">bufIsFull</a> (<a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf)</td></tr>
<tr class="separator:a45df30f7a8af5351fd39aa38c3708854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b22f758227c6f921b98c3586ef7655"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_defs_8h.html#a45b22f758227c6f921b98c3586ef7655">bufHasData</a> (<a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf)</td></tr>
<tr class="separator:a45b22f758227c6f921b98c3586ef7655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a577150bd6a04fcc89fa79e7448708408"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_defs_8h.html#a577150bd6a04fcc89fa79e7448708408">bufHasSpace</a> (<a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf)</td></tr>
<tr class="separator:a577150bd6a04fcc89fa79e7448708408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a814218a2cf4602f25aefe248f8f6c923"><td class="memItemLeft" align="right" valign="top">WORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_defs_8h.html#a814218a2cf4602f25aefe248f8f6c923">bufGetCount</a> (<a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf)</td></tr>
<tr class="separator:a814218a2cf4602f25aefe248f8f6c923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f1012a7bec1259a301f32ec32c82ef4"><td class="memItemLeft" align="right" valign="top">WORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_defs_8h.html#a4f1012a7bec1259a301f32ec32c82ef4">bufGetFree</a> (<a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf)</td></tr>
<tr class="separator:a4f1012a7bec1259a301f32ec32c82ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e986c91481cdcb8f1c5fb16896efb8d"><td class="memItemLeft" align="right" valign="top">BYTE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_defs_8h.html#a3e986c91481cdcb8f1c5fb16896efb8d">bufPeekByte</a> (<a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf)</td></tr>
<tr class="separator:a3e986c91481cdcb8f1c5fb16896efb8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a667031679d0ec879aa690787280c56af"><td class="memItemLeft" align="right" valign="top">BYTE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_defs_8h.html#a667031679d0ec879aa690787280c56af">bufPeekByteAt</a> (<a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf, WORD offset)</td></tr>
<tr class="separator:a667031679d0ec879aa690787280c56af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc29b857c5c223418f3369558fefb21"><td class="memItemLeft" align="right" valign="top">WORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_defs_8h.html#abdc29b857c5c223418f3369558fefb21">bufFindByte</a> (<a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf, WORD offset, BYTE value)</td></tr>
<tr class="separator:abdc29b857c5c223418f3369558fefb21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a665bc6426bcf35d51a2b2d5c341f945e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_defs_8h.html#a665bc6426bcf35d51a2b2d5c341f945e">bufRemoveByte</a> (<a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf)</td></tr>
<tr class="separator:a665bc6426bcf35d51a2b2d5c341f945e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af21269f3abf65e2b9a9905fe51e340c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_defs_8h.html#af21269f3abf65e2b9a9905fe51e340c0">bufRemoveBytes</a> (<a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf, WORD n)</td></tr>
<tr class="separator:af21269f3abf65e2b9a9905fe51e340c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b7e8cac873ccaf7c3abb254d3628153"><td class="memItemLeft" align="right" valign="top">BYTE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_defs_8h.html#a5b7e8cac873ccaf7c3abb254d3628153">bufGetByte</a> (<a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf)</td></tr>
<tr class="separator:a5b7e8cac873ccaf7c3abb254d3628153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38e8041365650983e33b1c1e04013e34"><td class="memItemLeft" align="right" valign="top">BYTE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_defs_8h.html#a38e8041365650983e33b1c1e04013e34">bufGetByte_SV</a> (<a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf)</td></tr>
<tr class="separator:a38e8041365650983e33b1c1e04013e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a526f8ca151f9b9e98a07e0278cf0b79f"><td class="memItemLeft" align="right" valign="top">WORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_defs_8h.html#a526f8ca151f9b9e98a07e0278cf0b79f">bufGetArray</a> (<a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf, BYTE *pArr, WORD size)</td></tr>
<tr class="separator:a526f8ca151f9b9e98a07e0278cf0b79f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedd0c2685eeea9308c08ff6fc404efa8"><td class="memItemLeft" align="right" valign="top">WORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_defs_8h.html#aedd0c2685eeea9308c08ff6fc404efa8">bufGetArrayTillByte</a> (<a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf, BYTE *pArr, BYTE value, WORD size)</td></tr>
<tr class="separator:aedd0c2685eeea9308c08ff6fc404efa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd7af1d0e31e70d30eb191229cf56cd"><td class="memItemLeft" align="right" valign="top">WORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_defs_8h.html#a4bd7af1d0e31e70d30eb191229cf56cd">bufGetRdArrSize</a> (<a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf)</td></tr>
<tr class="separator:a4bd7af1d0e31e70d30eb191229cf56cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad412401e003a7cbe39bc80a8633e9e86"><td class="memItemLeft" align="right" valign="top">BYTE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_defs_8h.html#ad412401e003a7cbe39bc80a8633e9e86">bufGetRdArr</a> (<a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf)</td></tr>
<tr class="separator:ad412401e003a7cbe39bc80a8633e9e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a994381f6d2ccbe5884556adaa315e106"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_defs_8h.html#a994381f6d2ccbe5884556adaa315e106">bufPutByte</a> (<a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf, BYTE b)</td></tr>
<tr class="separator:a994381f6d2ccbe5884556adaa315e106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3e9fef35fe5365fbc45a53c27842bef"><td class="memItemLeft" align="right" valign="top">WORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_defs_8h.html#ac3e9fef35fe5365fbc45a53c27842bef">bufPutString</a> (<a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf, const char *s)</td></tr>
<tr class="separator:ac3e9fef35fe5365fbc45a53c27842bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78dbceffbb8820640adce9d88608c4f6"><td class="memItemLeft" align="right" valign="top">WORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_defs_8h.html#a78dbceffbb8820640adce9d88608c4f6">bufPutStringWait</a> (<a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf, const char *s)</td></tr>
<tr class="separator:a78dbceffbb8820640adce9d88608c4f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbcef27ab283a89b57da33881dffb926"><td class="memItemLeft" align="right" valign="top">WORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_defs_8h.html#acbcef27ab283a89b57da33881dffb926">bufPutArray</a> (<a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf, const BYTE *pArr, WORD size)</td></tr>
<tr class="separator:acbcef27ab283a89b57da33881dffb926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08eb07826c48180335e4d6d28aa7ad9b"><td class="memItemLeft" align="right" valign="top">WORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_defs_8h.html#a08eb07826c48180335e4d6d28aa7ad9b">bufPutArrayWait</a> (<a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf, const BYTE *pArr, WORD size)</td></tr>
<tr class="separator:a08eb07826c48180335e4d6d28aa7ad9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acde0b5fa5a895e9b6cc4b991be88a7f9"><td class="memItemLeft" align="right" valign="top">WORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_defs_8h.html#acde0b5fa5a895e9b6cc4b991be88a7f9">bufMove</a> (<a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBufSrc, <a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBufDst)</td></tr>
<tr class="separator:acde0b5fa5a895e9b6cc4b991be88a7f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a016bbb3025c74ede2a682c98b9444130"><td class="memItemLeft" align="right" valign="top">WORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_defs_8h.html#a016bbb3025c74ede2a682c98b9444130">bufGetWrArrSize</a> (<a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf)</td></tr>
<tr class="separator:a016bbb3025c74ede2a682c98b9444130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f00abac0192deb7a7482db0556a686"><td class="memItemLeft" align="right" valign="top">BYTE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_defs_8h.html#a59f00abac0192deb7a7482db0556a686">bufGetWrArr</a> (<a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf)</td></tr>
<tr class="separator:a59f00abac0192deb7a7482db0556a686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37bfaaac389f19ddac16481577c46a8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_defs_8h.html#a37bfaaac389f19ddac16481577c46a8e">bufUpdatePut</a> (<a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf, WORD n)</td></tr>
<tr class="separator:a37bfaaac389f19ddac16481577c46a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44e8e62dc62a7f79d530730466c7cd37"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_defs_8h.html#a44e8e62dc62a7f79d530730466c7cd37">bufGetError</a> (<a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf)</td></tr>
<tr class="separator:a44e8e62dc62a7f79d530730466c7cd37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35a23f38a76d847d9a2742014d5f1a4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_defs_8h.html#a35a23f38a76d847d9a2742014d5f1a4a">bufClearError</a> (<a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf)</td></tr>
<tr class="separator:a35a23f38a76d847d9a2742014d5f1a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba11f0d9a3775acf487650dfcbd7ff3"><td class="memItemLeft" align="right" valign="top">BYTE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_defs_8h.html#aeba11f0d9a3775acf487650dfcbd7ff3">bufIsActive</a> (<a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf)</td></tr>
<tr class="separator:aeba11f0d9a3775acf487650dfcbd7ff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea252b9f2e9d9c048d3ff1d10fa4393e"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_defs_8h.html#aea252b9f2e9d9c048d3ff1d10fa4393e">bufIsPacket</a> (<a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf)</td></tr>
<tr class="separator:aea252b9f2e9d9c048d3ff1d10fa4393e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa66f430be24b4964b7cd3783b8a6f17c"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_defs_8h.html#aa66f430be24b4964b7cd3783b8a6f17c">bufIsPacketLarge</a> (<a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf)</td></tr>
<tr class="separator:aa66f430be24b4964b7cd3783b8a6f17c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099b940faa0e8b5ffe3721b9d7979b5d"><td class="memItemLeft" align="right" valign="top">WORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_defs_8h.html#a099b940faa0e8b5ffe3721b9d7979b5d">bufHasWholePacket</a> (<a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf)</td></tr>
<tr class="separator:a099b940faa0e8b5ffe3721b9d7979b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80ef2908f0b5aa5f7688f2f013595973"><td class="memItemLeft" align="right" valign="top">WORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_defs_8h.html#a80ef2908f0b5aa5f7688f2f013595973">bufPutPacket</a> (<a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf, const BYTE *pArr, WORD size)</td></tr>
<tr class="separator:a80ef2908f0b5aa5f7688f2f013595973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa27c7a4b736a0964ebc908fe87ab600"><td class="memItemLeft" align="right" valign="top">WORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_defs_8h.html#aaa27c7a4b736a0964ebc908fe87ab600">bufGetPacketDataSize</a> (<a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf)</td></tr>
<tr class="separator:aaa27c7a4b736a0964ebc908fe87ab600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28a816b12c591b910ddc4d67ff396c0c"><td class="memItemLeft" align="right" valign="top">WORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_defs_8h.html#a28a816b12c591b910ddc4d67ff396c0c">bufPeekPacketDataSize</a> (<a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf)</td></tr>
<tr class="separator:a28a816b12c591b910ddc4d67ff396c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5f26b41c03a6ba0d7a8102a0035e1ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_defs_8h.html#aa5f26b41c03a6ba0d7a8102a0035e1ff">bufTask</a> (void)</td></tr>
<tr class="separator:aa5f26b41c03a6ba0d7a8102a0035e1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains global data for user apps to access system data. </p>
<dl class="section author"><dt>Author</dt><dd><a href="www.modtronix.com">Modtronix Engineering</a> </dd></dl>
<dl class="section user"><dt>Compiler:</dt><dd>MPLAB XC16 compiler</dd></dl>
<h1><a class="anchor" id="nz_circularBufferDefs_desc"></a>
Description</h1>
<p>This module contains global accessable data to allow applications to be able to access system data. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a5ee4bec8a4b44ba8159671c328a3cbac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUFFORMAT_ASCII&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Buffer is in ASCII (plain text) format </p>

</div>
</div>
<a class="anchor" id="a1ffa606c2c5349f618ac511fa4623fe5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUFFORMAT_ASCII_ESC&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Buffer is in ASCII format (plain text), with Escape sequence (Control Character) processing. The '\' is the escape character. Standard Two '\' characters following each other represent a single '\' character. </p>

</div>
</div>
<a class="anchor" id="af2d9a24e4030ad1a2d8e14a1878d1b9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUFFORMAT_BIN&#160;&#160;&#160;3</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Buffer is in plain Binary format. No processing of the data is done. </p>

</div>
</div>
<a class="anchor" id="a0c886ac5ee84be8805b456298e4f2246"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUFFORMAT_BIN_ESC&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Buffer is in plain Binary format, with Escape sequence processing. The '\' is the escape character. Two '\' characters following each other represent a single '\' character. Exact processing of Escape sequence depends on buffer type, and how it processes them. For example, an I2C buffer could interpret '\[0-9][A-F]' as a hex value (\F3 for example), and '\S' as a Start bit. </p>

</div>
</div>
<a class="anchor" id="a9221a287e697c595025dfb40948593de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUFFORMAT_NONE&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Buffer has no formatting. </p>

</div>
</div>
<a class="anchor" id="a81cc30bc033bb2f5f3c5c53e98e05467"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUFTYPE_PACKET&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Packet buffer type, maximum 255 bytes long. Each packet added has the format:<br/>
 [Size 8-bit][Data]</p>
<ul>
<li><b>size</b>: Is the 8-bit size of data to follow</li>
<li><b>data</b>: The data</li>
</ul>
<p>New packet is only added if there is enough space, ensuring buffer does not get corrupted. If no space, low level code responsible for adding packet might send failure message to sender, requesting it is sent again at a later stage. Get size of packet (data part, whole packet is one more) with bufGetPacketDataSize(CIRBUF_RX_xxx) function </p>

</div>
</div>
<a class="anchor" id="a8a7dd9bdc0986eef069ee8b3db97c903"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUFTYPE_PACKET_LARGE&#160;&#160;&#160;3</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Large Packet buffer type, maximum 65,535 bytes long. Each packet added has the format:<br/>
 [Size 16-bit][Data] = [size MSB][size LSB][data]</p>
<ul>
<li><b>size</b>: Is the 16-bit size of data to follow. Fist byte (<a class="el" href="nz__circular_buffer_std_8h.html#a4acc705d927f4fb0dbe7970072b7f63e">bufPeekByte(pBuf)</a>) is MSB part of size.</li>
<li><b>data</b>: The data</li>
</ul>
<p>Same as BUFTYPE_PACKET, but larger possible data. Get size of packet (data part, whole packet is one more) with bufGetLargePacketSize(CIRBUF_RX_xxx) function </p>

</div>
</div>
<a class="anchor" id="a7580fd955704af7e52cd60b05434fe72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUFTYPE_STREAMING&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default buffer type. Streaming buffer, there is no formatting! As bytes are received they are added to the buffer. If buffer is already full, it is overwritten. </p>

</div>
</div>
<a class="anchor" id="a4fe9616eb78b28362e30a24f55a562ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CIRBUF_FLAGS_STREAM_POW2&#160;&#160;&#160;(BUFTYPE_POW2_MASK | <a class="el" href="nz__circular_buffer_defs_8h.html#a7580fd955704af7e52cd60b05434fe72">BUFTYPE_STREAMING</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use to initialize CIRBUF.typeVal, sets buffer to streaming buffer, with Power of 2 size </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="abe1952d063f6dc2949499653d4ad778c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct___c_i_r_b_u_f.html">_CIRBUF</a>  <a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Circular Buffer Structure, for buffers with maximum size of 65535. Exactly the same as CIRBUF structure, but flagBits.bSizePower2 flag must be clear. Use bufXxx functions with this structure. bufXxx functions always work, and buffXxx are optimzed functions for when buffer size is a power of 2. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a35a23f38a76d847d9a2742014d5f1a4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bufClearError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears all error flags.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF_VARIABLE structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a44197044ef28ff80bbc09834942ae6be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bufEmpty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Empty the given buffer. Any data contained in the buffer is lost.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abdc29b857c5c223418f3369558fefb21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WORD bufFindByte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WORD&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find first occurance of given byte. The offset in the buffer is returned. For example, if the string is "Name=Mark", and we call bufFindByte(pBuf, 0, '='), it will return 4 (index of =).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure</td></tr>
    <tr><td class="paramname">offset</td><td>Offset to start the search from, 0 is start of buffer. NOT SUPPORTED YET, but will be in future!</td></tr>
    <tr><td class="paramname">value</td><td>Byte to search forl</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Offset of byte, or -1 of not found </dd></dl>

</div>
</div>
<a class="anchor" id="a526f8ca151f9b9e98a07e0278cf0b79f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WORD bufGetArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE *&#160;</td>
          <td class="paramname"><em>pArr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WORD&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies given number of bytes to buffer, and returns actual number of bytes copied. If returned value is less than given size, all bytes were copies from source pBuf, and it didn't have enough bytes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to source CIRBUF structure, that data is copied from </td></tr>
    <tr><td class="paramname">pArr</td><td>Pointer to destination BYTE array </td></tr>
    <tr><td class="paramname">size</td><td>Maximum number of bytes to copy. Could be less if pBuf contains less</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns number of bytes added to array. </dd></dl>

</div>
</div>
<a class="anchor" id="aedd0c2685eeea9308c08ff6fc404efa8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WORD bufGetArrayTillByte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE *&#160;</td>
          <td class="paramname"><em>pArr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WORD&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies given number of bytes to destination array, and remove them from source buffer (pBuf). Is only done if given byte is found, or end of source buffer reached. Returns number of bytes copied.</p>
<p>If size is exceeded, -1 is returned, and no bytes are removed from source buffer! A side affect is that bytes will still be copied to given destination array (pArr), but nothing is removed from source buffer!</p>
<p>!!!! IMPORTANT !!!! Note that if given byte not found, or end of source buffer not reached, nothing is removed from source buffer and -1 is returned. This is the case if the size of the given destination array (size parameter) is reached. Bytes (size) are still copied to destination array (pArr).</p>
<p>Some examples: <br/>
If the string is "Name=Value", and we call bufGetArrayTillByte(pBuf, pArr, '=', 20): <br/>
- The string "Name=" (5 bytes) will be removed from pBuf, and copied to pArr. Returns 5</p>
<p><br/>
If the string is "Name=Value", and we call bufGetArrayTillByte(pBuf, pArr, '=', 3): <br/>
- NOTHING is removed from pBuf! The string "Nam" (3 bytes) is however still copied to pArr. Returns -1</p>
<p><br/>
If the string is "Value", and we call bufGetArrayTillByte(pBuf, pArr, '&amp;', 20): <br/>
- The string "Value" (5 bytes) will be removed from pBuf, and copied to pArr. Returns 5</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to source CIRBUF structure, that data is copied from </td></tr>
    <tr><td class="paramname">pArr</td><td>Pointer to destination BYTE array </td></tr>
    <tr><td class="paramname">value</td><td>Byte to search for </td></tr>
    <tr><td class="paramname">size</td><td>Maximum number of bytes to copy to pArr.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns number of bytes copied to destination array and removed from source buffer, or -1 if nothing removed. NOTE that if -1 returned, bytes are still copied to destination array, but nothing is removed from source buffer </dd></dl>

</div>
</div>
<a class="anchor" id="a5b7e8cac873ccaf7c3abb254d3628153"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BYTE bufGetByte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets a byte from the Buffer, and removes it from buffer.</p>
<dl class="section user"><dt>Pre-Condition:</dt><dd><a class="el" href="nz__circular_buffer_defs_8h.html#a7868f6cfcf7c84ba71ee799dd05194f2">bufIsEmpty()</a> must have been called to confirm the buffer has data!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the next byte in the given buffer. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="usb_2device__m_i_d_i__l_c_d_2main_8c-example.html#a5">usb/device_MIDI_LCD/main.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a38e8041365650983e33b1c1e04013e34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BYTE bufGetByte_SV </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets a byte from the Buffer, and removes it from buffer. SV (Simple version) - only use simple = expression, like "c=bufGetByte_SV(pBuf);" ! !!!! IMPORTANT !!!! Never use in statment, but only on single line. DON'T use like this: if ((i = bufGetByte(1)) &gt; 1) Use like that: i = bufGetByte(1);</p>
<dl class="section user"><dt>Pre-Condition:</dt><dd><a class="el" href="nz__circular_buffer_defs_8h.html#a7868f6cfcf7c84ba71ee799dd05194f2">bufIsEmpty()</a> must have been called to confirm the buffer has data!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the next byte in the given buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="a814218a2cf4602f25aefe248f8f6c923"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WORD bufGetCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets number of bytes available in buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns number of bytes available in buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="a44e8e62dc62a7f79d530730466c7cd37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL bufGetError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the bErrorFull flag. Use the <a class="el" href="nz__circular_buffer_defs_8h.html#a35a23f38a76d847d9a2742014d5f1a4a">bufClearError()</a> function to clear the error flag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF_VARIABLE structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bErrorFull flag </dd></dl>

</div>
</div>
<a class="anchor" id="a4f1012a7bec1259a301f32ec32c82ef4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WORD bufGetFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets number of free bytes available in buffer. This is how much space is available for writing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns number of free bytes available in buffer. This is maximum bytes we can write to buffer </dd></dl>

</div>
</div>
<a class="anchor" id="aaa27c7a4b736a0964ebc908fe87ab600"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WORD bufGetPacketDataSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if size part of packet(size of packet data) is in buffer, and if so, get and remove it. No check is done to see if data part of packet is already in buffer. The packet size can be either a 8-bit (BUFTYPE_PACKET) or a 16-bit (BUFTYPE_PACKET) value. It gives the size of the data part of the packet to follow. After calling this function, the data part remains in the buffer and MUST be processed and removed! Use <a class="el" href="nz__circular_buffer_defs_8h.html#a28a816b12c591b910ddc4d67ff396c0c">bufPeekPacketDataSize()</a> to get size without removing it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF circular buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns size of packet data. A value from 1 to 255 for a BUFTYPE_PACKET, and 1-65535 for a BUFTYPE_PACKET_LARGE. Returns 0 if buffer empty, OR does not contain a packet, OR size part of packet not available. </dd></dl>

</div>
</div>
<a class="anchor" id="ad412401e003a7cbe39bc80a8633e9e86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BYTE* bufGetRdArr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Macro for getting byte pointer to current GET location. Use this Macro with <a class="el" href="nz__circular_buffer_defs_8h.html#a4bd7af1d0e31e70d30eb191229cf56cd">bufGetRdArrSize()</a> function.</p>
<dl class="section return"><dt>Returns</dt><dd>BYTE pointer to current GET location </dd></dl>

</div>
</div>
<a class="anchor" id="a4bd7af1d0e31e70d30eb191229cf56cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WORD bufGetRdArrSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets number of contiguous bytes that can be read from buffer. Bytes are NOT removed! Call <a class="el" href="nz__circular_buffer_pwr2_8h.html#a27b30cf591e67c5568631c7dda25f34e">bufRemoveBytes(n)</a> to remove bytes if required. Bytes can be read from cirbuf.buf[ cirbuf.get ]. Call <a class="el" href="nz__circular_buffer_std_8h.html#a2bb88ea0266468fa85faf7c847cb571e">bufHasData()</a> to see if more bytes available when done. Note that if available bytes cross buffer end boundry, there will be 2 congiguous blocks of data.</p>
<p>!!!! IMPORTANT !!!! Remember to call <a class="el" href="nz__circular_buffer_pwr2_8h.html#a27b30cf591e67c5568631c7dda25f34e">bufRemoveBytes(n)</a> to remove bytes if required.</p>
<p>For Eexample: WORD size, byteWritten; //Get number of bytes available for reading size = <a class="el" href="nz__circular_buffer_std_8h.html#ae3e06d3385aee1166dde5e2cfbb67ef1">bufGetRdArrSize(&amp;cirbuf)</a>; //Call some function that requires an array and size as input parameters byteWritten = usbPutArr( <a class="el" href="nz__circular_buffer_std_8h.html#aa1a4c474c257feac92db20114fe14eb8">bufGetRdArr(&amp;cirbuf)</a>, size); //Now remove bytes from buffer <a class="el" href="nz__circular_buffer_pwr2_8h.html#a27b30cf591e67c5568631c7dda25f34e">bufRemoveBytes(&amp;cirbuf, byteWritten)</a>;</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes available in returned buffer </dd></dl>

</div>
</div>
<a class="anchor" id="a59f00abac0192deb7a7482db0556a686"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BYTE* bufGetWrArr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Macro for getting byte pointer to current PUT location. Use this Macro with <a class="el" href="nz__circular_buffer_defs_8h.html#a016bbb3025c74ede2a682c98b9444130">bufGetWrArrSize()</a> function. </p>

</div>
</div>
<a class="anchor" id="a016bbb3025c74ede2a682c98b9444130"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WORD bufGetWrArrSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets number of contiguous bytes that can be written to buffer. Buffer PUT pointer is NOT updated! Call <a class="el" href="nz__circular_buffer_pwr2_8h.html#aeb51478c8065e8202f4ce34ff5d58cbc">bufUpdatePut()</a> to update PUT pointer. Bytes can be written to cirbuf.buf[ cirbuf.put ]. Call <a class="el" href="nz__circular_buffer_defs_8h.html#a45df30f7a8af5351fd39aa38c3708854">bufIsFull()</a> to see if more bytes can be written when done (and PUT pointer updated). Note that if available bytes cross buffer end boundry, there will be 2 congiguous blocks of data.</p>
<p>!!!! IMPORTANT !!!! Remember to call <a class="el" href="nz__circular_buffer_pwr2_8h.html#aeb51478c8065e8202f4ce34ff5d58cbc">bufUpdatePut()</a> to update PUT pointer after adding bytes to array.</p>
<p>For Example: WORD size, bytesRead; //Get number of bytes available that can be written to buffer array size = bufGetWrArrSize(&amp;cirbuf); //Call some function that requires an array and size as input parameters bytesRead = usbGetArr( <a class="el" href="nz__circular_buffer_std_8h.html#a8096389182174b1dde5669820fa46c5f">bufGetWrArr(&amp;cirbuf)</a>, size); //Now update PUT pointer with bytes written <a class="el" href="nz__circular_buffer_pwr2_8h.html#aeb51478c8065e8202f4ce34ff5d58cbc">bufUpdatePut(&amp;cirbuf, bytesRead)</a>;</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes available in returned buffer </dd></dl>

</div>
</div>
<a class="anchor" id="a45b22f758227c6f921b98c3586ef7655"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOL bufHasData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if the given buffer contains data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the given buffer has data. </dd></dl>

</div>
</div>
<a class="anchor" id="a577150bd6a04fcc89fa79e7448708408"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL bufHasSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if the given buffer is not full. Has space for adding data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the given buffer has data. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="usb_2device__m_i_d_i__l_c_d_2main_8c-example.html#a2">usb/device_MIDI_LCD/main.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a099b940faa0e8b5ffe3721b9d7979b5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WORD bufHasWholePacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates if given buffer contains a whole packet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 if false, else size of Packet Data.</dd></dl>
<p>Indicates if buffer contains a whole packet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 if false, else size of whole Packet (size and data part of packet). </dd></dl>

</div>
</div>
<a class="anchor" id="aeba11f0d9a3775acf487650dfcbd7ff3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BYTE bufIsActive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates if given buffer is active. A buffer is active when bit is set in 'ser.avail' structure in cfgStruct.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 if not active, else 1 </dd></dl>

</div>
</div>
<a class="anchor" id="a7868f6cfcf7c84ba71ee799dd05194f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL bufIsEmpty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if the given buffer is empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the given buffer is empty. Else, returns false. </dd></dl>

</div>
</div>
<a class="anchor" id="a45df30f7a8af5351fd39aa38c3708854"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL bufIsFull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if the given transmit buffer is full - no more space for adding data. This is the case when put+1 = get</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the given buffer is full. Else, returns false. </dd></dl>

</div>
</div>
<a class="anchor" id="aea252b9f2e9d9c048d3ff1d10fa4393e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL bufIsPacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates if given buffer is a Packet. <br/>
!!! IMPORTANT !!!<br/>
 If true, tt can be a normal (8-bit size = BUFTYPE_PACKET) or large(16-bit size = BUFTYPE_PACKET_LARGE) packet. Call <a class="el" href="nz__circular_buffer_defs_8h.html#aa66f430be24b4964b7cd3783b8a6f17c">bufIsPacketLarge()</a> function to see if it is a large packet type, else it is small.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 1 if this is a Packet buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="aa66f430be24b4964b7cd3783b8a6f17c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL bufIsPacketLarge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates if given buffer is a Large Packet. This is the case if the bPacketLarge flag is set. <br/>
!!! IMPORTANT !!!<br/>
 This function does not check it is is a packet, but only the bPacketLarge flag. This flag is only valid if this buffer is a packet type. First use <a class="el" href="nz__circular_buffer_defs_8h.html#aea252b9f2e9d9c048d3ff1d10fa4393e">bufIsPacket()</a> function to check if this buffer is a packet. To check if this buffer is a packet AND if it is a large packet, use: if (<a class="el" href="nz__circular_buffer_defs_8h.html#aea252b9f2e9d9c048d3ff1d10fa4393e">bufIsPacket()</a> &amp;&amp; <a class="el" href="nz__circular_buffer_defs_8h.html#aa66f430be24b4964b7cd3783b8a6f17c">bufIsPacketLarge()</a>) { .... }</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 1 if this is Large Packet buffer (has a 16-bit size field). </dd></dl>

</div>
</div>
<a class="anchor" id="acde0b5fa5a895e9b6cc4b991be88a7f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WORD bufMove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBufSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBufDst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves as many bytes as possible from given source buffer (BIFCIR), to given destination buffer (CIRBUF). This function checks how many Source bytes are available, and maximum number of bytes that can be added to Destination.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBufSrc</td><td>Pointer to Source CIRBUF structure </td></tr>
    <tr><td class="paramname">pBufDst</td><td>Pointer to Source CIRBUF structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns number of bytes moved from source to destination buffers. </dd></dl>

</div>
</div>
<a class="anchor" id="a3e986c91481cdcb8f1c5fb16896efb8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BYTE bufPeekByte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets a byte from the Buffer, without removing it. The byte is NOT removed from the buffer, and the buffer pointers are NOT updated! To remove the byte, and update the pointers, call the <a class="el" href="nz__circular_buffer_defs_8h.html#a665bc6426bcf35d51a2b2d5c341f945e">bufRemoveByte()</a> function.</p>
<dl class="section user"><dt>Pre-Condition:</dt><dd><a class="el" href="nz__circular_buffer_defs_8h.html#a7868f6cfcf7c84ba71ee799dd05194f2">bufIsEmpty()</a> must have been called to confirm the Buffer has data!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the next byte in the given buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="a667031679d0ec879aa690787280c56af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BYTE bufPeekByteAt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WORD&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets a byte at the given offset from the Buffer, without removing it. The byte is NOT removed from the buffer, and the buffer pointers are NOT updated! The byte at the given offset it returned. The offset is how deep the byte is in the buffer. For example, 0 will return first byte in buffer, 5 will return the 6th byte in the buffer.</p>
<dl class="section user"><dt>Pre-Condition:</dt><dd>Ensure offset parameter is not larger than current number of byte contained in buffer. Call <a class="el" href="nz__circular_buffer_defs_8h.html#a814218a2cf4602f25aefe248f8f6c923">bufGetCount()</a> to get current number of bytes in buffer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure </td></tr>
    <tr><td class="paramname">offset</td><td>Offset of byte to return. Is a value from 0-n, where n = (<a class="el" href="nz__circular_buffer_defs_8h.html#a814218a2cf4602f25aefe248f8f6c923">bufGetCount()</a> - 1)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the byte at the given offset in the given buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="a28a816b12c591b910ddc4d67ff396c0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WORD bufPeekPacketDataSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check size part of packet(size of packet data) is in buffer, and if so, get it. No check is done to see if data part of packet is already in buffer. The packet size can be either a 8-bit (BUFTYPE_PACKET) or a 16-bit (BUFTYPE_PACKET) value. It gives the size of the data part of the packet to follow. Nothing is removed from the buffer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF circular buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 if size part of packet not available, or size of packet. A value from 1 to 255 for a BUFTYPE_PACKET, and 1-65535 for a BUFTYPE_PACKET_LARGE </dd></dl>

</div>
</div>
<a class="anchor" id="acbcef27ab283a89b57da33881dffb926"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WORD bufPutArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BYTE *&#160;</td>
          <td class="paramname"><em>pArr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WORD&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds given number of bytes to buffer. This function checks given buffer has enough space. The actual number of bytes written is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure </td></tr>
    <tr><td class="paramname">pArr</td><td>Pointer to source BYTE array </td></tr>
    <tr><td class="paramname">size</td><td>Number of bytes to copy</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns number of bytes added to buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="a08eb07826c48180335e4d6d28aa7ad9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WORD bufPutArrayWait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BYTE *&#160;</td>
          <td class="paramname"><em>pArr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WORD&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds given number of bytes to buffer. If buffer does not have enough space, this function will wait until space is available in buffer to add requested bytes. !!!!! IMPORTANT !!!!! Only call this function for buffers that use ISR to empty buffer. Else, buffer will never get empty if we wait for it!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure </td></tr>
    <tr><td class="paramname">pArr</td><td>Pointer to source BYTE array </td></tr>
    <tr><td class="paramname">size</td><td>Number of bytes to copy</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns number of bytes added to buffer. If a timeout occured, it will be less then the requested size. </dd></dl>

</div>
</div>
<a class="anchor" id="a994381f6d2ccbe5884556adaa315e106"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bufPutByte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a byte to the buffer, and updates the buffer pointers.</p>
<dl class="section user"><dt>Pre-Condition:</dt><dd><a class="el" href="nz__circular_buffer_defs_8h.html#a45df30f7a8af5351fd39aa38c3708854">bufIsFull()</a> must have been called to confirm the buffer is not full!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure </td></tr>
    <tr><td class="paramname">b</td><td>Byte to add to the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="usb_2device__m_i_d_i__l_c_d_2main_8c-example.html#a3">usb/device_MIDI_LCD/main.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a80ef2908f0b5aa5f7688f2f013595973"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WORD bufPutPacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BYTE *&#160;</td>
          <td class="paramname"><em>pArr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WORD&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds given number of bytes to buffer as a packet. This function checks given buffer has enough space, and either adds all given bytes, or nothing (not enough space). A Packet buffer has the format: [Size][Data] The size parameter must give the size of the source BYTE array (pArr parameter). It will be copied to the [Data] part of the Packet. The [Size] part can be a 8 or 16-bit value, depending if it is a normal or large packet buffer. Use the <a class="el" href="nz__circular_buffer_defs_8h.html#aa66f430be24b4964b7cd3783b8a6f17c">bufIsPacketLarge()</a> to determine if normal or large. When normal, function will fail is the size parameter is larger than 255.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to destination CIRBUF Circular Buffer. Packet is added to this buffer. </td></tr>
    <tr><td class="paramname">pArr</td><td>Pointer to source BYTE array. This is copied to the [Data] part of packet. </td></tr>
    <tr><td class="paramname">size</td><td>Size of source BYTE array(pArr).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns number of bytes added to buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="ac3e9fef35fe5365fbc45a53c27842bef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WORD bufPutString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds given NULL terminated string to buffer, and updates the buffer pointers. This function checks given buffer has enough space to add string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure </td></tr>
    <tr><td class="paramname">s</td><td>Null terminated string to add</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns number of bytes added to buffer. Zero is returned if buffer did not have enough space to add string. In this case, nothing is added to the buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="a78dbceffbb8820640adce9d88608c4f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WORD bufPutStringWait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds given NULL terminated string to buffer, and updates the buffer pointers. If the buffer is full, this function will wait until space is available in buffer to add string. !!!!! IMPORTANT !!!!! Only call this function for buffers that use ISR to empty buffer. Else, buffer will never get empty if we wait for it!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure </td></tr>
    <tr><td class="paramname">s</td><td>String to add to the buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns number of bytes added to buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="a665bc6426bcf35d51a2b2d5c341f945e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bufRemoveByte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes a byte from the Buffer.</p>
<dl class="section user"><dt>Pre-Condition:</dt><dd>Before calling this function, it must be confirmed that the buffer has data. The <a class="el" href="nz__circular_buffer_std_8h.html#a2bb88ea0266468fa85faf7c847cb571e">bufHasData()</a> is an example function that can be used to do this check.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af21269f3abf65e2b9a9905fe51e340c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bufRemoveBytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WORD&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes given number of bytes from the Buffer.</p>
<dl class="section user"><dt>Pre-Condition:</dt><dd>Before calling this function, it must be confirmed that the buffer has the requested number of bytes to remove.</dd></dl>
<p>!!! IMPORTANT !!! If more bytes are requested to be removed then available, bad things will happen!!!!!!!!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure </td></tr>
    <tr><td class="paramname">n</td><td>Number of bytes to remove </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa5f26b41c03a6ba0d7a8102a0035e1ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bufTask </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Must be called every couple of ms </p>

</div>
</div>
<a class="anchor" id="a37bfaaac389f19ddac16481577c46a8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bufUpdatePut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_defs_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WORD&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Increments PUT pointer by given size, taking care of any wrapping required. This function is meant to be used after writing bytes to a CIRBUF buffer's array obtained with <a class="el" href="nz__circular_buffer_defs_8h.html#a016bbb3025c74ede2a682c98b9444130">bufGetWrArrSize()</a> function. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_0497715779ca99cb1134d5ce544966ba.html">netcruzer</a></li><li class="navelem"><a class="el" href="dir_285a68def6f82363136d1caaa0fe0051.html">lib</a></li><li class="navelem"><a class="el" href="nz__circular_buffer_defs_8h.html">nz_circularBufferDefs.h</a></li>
    <li class="footer">Generated on Fri Aug 2 2013 12:04:38 for Netcruzer by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.4 </li>
  </ul>
</div>
</body>
</html>
