<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>Netcruzer Library API: netcruzer/lib/nz_circularBuffer.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Netcruzer Library API
   &#160;<span id="projectnumber">V2.03</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('nz__circular_buffer_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">nz_circularBuffer.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This file defines a Circular Buffer interface.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="nz__circular_buffer_pwr2_8h_source.html">nz_circularBufferPwr2.h</a>&quot;</code><br/>
</div>
<p><a href="nz__circular_buffer_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct___c_i_r_b_u_f.html">_CIRBUF</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a6efce8f0f2b33189d402b4ec320fc0e7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6efce8f0f2b33189d402b4ec320fc0e7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CIRBUF_USE_CIRCULAR_BUFFER_PWR2</b></td></tr>
<tr class="separator:a6efce8f0f2b33189d402b4ec320fc0e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20a2b03a15823ed538529483d912301f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a20a2b03a15823ed538529483d912301f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CIRBUF_MIN_SIZE</b>&#160;&#160;&#160;8</td></tr>
<tr class="separator:a20a2b03a15823ed538529483d912301f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a635051e93faa8d2c27cb0d480cf34a51"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#a635051e93faa8d2c27cb0d480cf34a51">CIRBUF_ESC_CHAR</a>&#160;&#160;&#160;'^'</td></tr>
<tr class="separator:a635051e93faa8d2c27cb0d480cf34a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add444d24fc4e31afa0b16aa26b0df054"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#add444d24fc4e31afa0b16aa26b0df054">CIRBUF_TYPE_STREAMING</a>&#160;&#160;&#160;0x0000</td></tr>
<tr class="separator:add444d24fc4e31afa0b16aa26b0df054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ffc8279962dab7ae703972908d4623"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#aa8ffc8279962dab7ae703972908d4623">CIRBUF_TYPE_PACKET</a>&#160;&#160;&#160;0x0001</td></tr>
<tr class="separator:aa8ffc8279962dab7ae703972908d4623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab323182818bc390d34ee553b25a93881"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#ab323182818bc390d34ee553b25a93881">CIRBUF_TYPE_LARGE_PACKET</a>&#160;&#160;&#160;0x0003</td></tr>
<tr class="separator:ab323182818bc390d34ee553b25a93881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a199375ffff167047518eaaae8a80b7a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a199375ffff167047518eaaae8a80b7a9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CIRBUF_FLAGS_POWER2</b>&#160;&#160;&#160;0x0020</td></tr>
<tr class="separator:a199375ffff167047518eaaae8a80b7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab484ba359723d9b5135d8a6d4e64878b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#ab484ba359723d9b5135d8a6d4e64878b">CIRBUF_FORMAT_NONE</a>&#160;&#160;&#160;0x0000</td></tr>
<tr class="separator:ab484ba359723d9b5135d8a6d4e64878b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9221a287e697c595025dfb40948593de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9221a287e697c595025dfb40948593de"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BUFFORMAT_NONE</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a9221a287e697c595025dfb40948593de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89bb65ab059e789c017f7facb05e8fee"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#a89bb65ab059e789c017f7facb05e8fee">CIRBUF_FORMAT_ASCII</a>&#160;&#160;&#160;0x0004</td></tr>
<tr class="separator:a89bb65ab059e789c017f7facb05e8fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee4bec8a4b44ba8159671c328a3cbac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ee4bec8a4b44ba8159671c328a3cbac"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BUFFORMAT_ASCII</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a5ee4bec8a4b44ba8159671c328a3cbac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a4f6c1a0c3f04f74721fad372129b24"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#a9a4f6c1a0c3f04f74721fad372129b24">CIRBUF_FORMAT_ASCII_ESC</a>&#160;&#160;&#160;0x0008</td></tr>
<tr class="separator:a9a4f6c1a0c3f04f74721fad372129b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ffa606c2c5349f618ac511fa4623fe5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ffa606c2c5349f618ac511fa4623fe5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BUFFORMAT_ASCII_ESC</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:a1ffa606c2c5349f618ac511fa4623fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cdac497b4733517fe99319636dffe30"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#a8cdac497b4733517fe99319636dffe30">CIRBUF_FORMAT_BIN</a>&#160;&#160;&#160;0x000C</td></tr>
<tr class="separator:a8cdac497b4733517fe99319636dffe30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d9a24e4030ad1a2d8e14a1878d1b9e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2d9a24e4030ad1a2d8e14a1878d1b9e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BUFFORMAT_BIN</b>&#160;&#160;&#160;3</td></tr>
<tr class="separator:af2d9a24e4030ad1a2d8e14a1878d1b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a294c2ccacd00786d3fa59b327f00240b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#a294c2ccacd00786d3fa59b327f00240b">CIRBUF_FORMAT_BIN_ESC</a>&#160;&#160;&#160;0x0010</td></tr>
<tr class="separator:a294c2ccacd00786d3fa59b327f00240b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c886ac5ee84be8805b456298e4f2246"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c886ac5ee84be8805b456298e4f2246"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BUFFORMAT_BIN_ESC</b>&#160;&#160;&#160;4</td></tr>
<tr class="separator:a0c886ac5ee84be8805b456298e4f2246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23271dae445b440574139341e3cae1ce"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#a23271dae445b440574139341e3cae1ce">cbufHasSpace</a>(pBuf)&#160;&#160;&#160;(<a class="el" href="nz__circular_buffer_8h.html#aaa470ac2cbb00d8a031a8f8062f261bd">cbufIsFull</a>(pBuf)==0)</td></tr>
<tr class="separator:a23271dae445b440574139341e3cae1ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b796c5210baef1474158edcb0e8a4df"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#a4b796c5210baef1474158edcb0e8a4df">cbufGetEscapeCharacter</a>(pBuf)&#160;&#160;&#160;(<a class="el" href="nz__circular_buffer_8h.html#a635051e93faa8d2c27cb0d480cf34a51">CIRBUF_ESC_CHAR</a>)</td></tr>
<tr class="separator:a4b796c5210baef1474158edcb0e8a4df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a632425a9c5a59c3b6c3c28630e028"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#a82a632425a9c5a59c3b6c3c28630e028">ASCIIESC_ADD_S_AND_P</a>&#160;&#160;&#160;0x0001</td></tr>
<tr class="separator:a82a632425a9c5a59c3b6c3c28630e028"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:abe1952d063f6dc2949499653d4ad778c"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct___c_i_r_b_u_f.html">_CIRBUF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a></td></tr>
<tr class="separator:abe1952d063f6dc2949499653d4ad778c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:adfb2a7b92818bd34c1296738baf4488a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#adfb2a7b92818bd34c1296738baf4488a">cbufInitDefault</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf, BYTE *bufArray, WORD size)</td></tr>
<tr class="separator:adfb2a7b92818bd34c1296738baf4488a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ea37f827a113e2451b36e8ce603f2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#a52ea37f827a113e2451b36e8ce603f2b">cbufInit</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf, BYTE *bufArray, WORD size, BYTE typeFormat)</td></tr>
<tr class="separator:a52ea37f827a113e2451b36e8ce603f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b2bf7f54e0d38e478ac7f6a645b58a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#a74b2bf7f54e0d38e478ac7f6a645b58a">cbufTask</a> (void)</td></tr>
<tr class="separator:a74b2bf7f54e0d38e478ac7f6a645b58a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f0fbbb5867303684efb705319bb2f9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#a0f0fbbb5867303684efb705319bb2f9b">cbufSetTypeAndFormat</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf, BYTE typeFormat)</td></tr>
<tr class="separator:a0f0fbbb5867303684efb705319bb2f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7770b7064483faee83b2711323d2c685"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#a7770b7064483faee83b2711323d2c685">cbufEmpty</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf)</td></tr>
<tr class="separator:a7770b7064483faee83b2711323d2c685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee28b1631393336e0bcda4901f0fea95"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#aee28b1631393336e0bcda4901f0fea95">cbufIsEmpty</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf)</td></tr>
<tr class="separator:aee28b1631393336e0bcda4901f0fea95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa470ac2cbb00d8a031a8f8062f261bd"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#aaa470ac2cbb00d8a031a8f8062f261bd">cbufIsFull</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf)</td></tr>
<tr class="separator:aaa470ac2cbb00d8a031a8f8062f261bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579f2af0e162697025c54bd7c1026203"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#a579f2af0e162697025c54bd7c1026203">cbufHasData</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf)</td></tr>
<tr class="separator:a579f2af0e162697025c54bd7c1026203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b57fbfd7719fe18b0cdfa42594f6824"><td class="memItemLeft" align="right" valign="top">WORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#a4b57fbfd7719fe18b0cdfa42594f6824">cbufGetCount</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf)</td></tr>
<tr class="separator:a4b57fbfd7719fe18b0cdfa42594f6824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0217704752fe13b84a324f4b1a2cd35"><td class="memItemLeft" align="right" valign="top">WORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#ae0217704752fe13b84a324f4b1a2cd35">cbufGetFree</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf)</td></tr>
<tr class="separator:ae0217704752fe13b84a324f4b1a2cd35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e58233528209d1336254424c386695f"><td class="memItemLeft" align="right" valign="top">BYTE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#a4e58233528209d1336254424c386695f">cbufGetFormat</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf)</td></tr>
<tr class="separator:a4e58233528209d1336254424c386695f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eccf756cb70b14b4ef500acb66b622e"><td class="memItemLeft" align="right" valign="top">BYTE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#a3eccf756cb70b14b4ef500acb66b622e">cbufGetType</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf)</td></tr>
<tr class="separator:a3eccf756cb70b14b4ef500acb66b622e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e4322c29348df4805f2ca4c837b9031"><td class="memItemLeft" align="right" valign="top">WORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#a0e4322c29348df4805f2ca4c837b9031">cbufGetEscapedSizeRequired</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf, BYTE *buf, WORD size)</td></tr>
<tr class="separator:a0e4322c29348df4805f2ca4c837b9031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a803165bec5c4642312e1b47ddba6e802"><td class="memItemLeft" align="right" valign="top">BYTE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#a803165bec5c4642312e1b47ddba6e802">cbufPeekByte</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf)</td></tr>
<tr class="separator:a803165bec5c4642312e1b47ddba6e802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ecd83b7bc6a9102750b94c840dc2d4"><td class="memItemLeft" align="right" valign="top">BYTE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#ad5ecd83b7bc6a9102750b94c840dc2d4">cbufPeekByteAt</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf, WORD offset)</td></tr>
<tr class="separator:ad5ecd83b7bc6a9102750b94c840dc2d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7826fc3569e8a6701451d2978fbac165"><td class="memItemLeft" align="right" valign="top">BYTE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#a7826fc3569e8a6701451d2978fbac165">cbufPeekEscapedByte</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf, BYTE *b)</td></tr>
<tr class="separator:a7826fc3569e8a6701451d2978fbac165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a526e2623362c316b486a0619319a9ec7"><td class="memItemLeft" align="right" valign="top">WORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#a526e2623362c316b486a0619319a9ec7">cbufFindByte</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf, WORD offset, BYTE value)</td></tr>
<tr class="separator:a526e2623362c316b486a0619319a9ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0cc2806944c8d224fb550bd2eb8abc3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#aa0cc2806944c8d224fb550bd2eb8abc3">cbufRemoveByte</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf)</td></tr>
<tr class="separator:aa0cc2806944c8d224fb550bd2eb8abc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f867ce6449e44ac7ba4083cf09c27d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#ae0f867ce6449e44ac7ba4083cf09c27d">cbufRemoveBytes</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf, WORD n)</td></tr>
<tr class="separator:ae0f867ce6449e44ac7ba4083cf09c27d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3bc759924f6ce0721f5ae5bd5d7a0dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#ab3bc759924f6ce0721f5ae5bd5d7a0dc">cbufRemovePutByte</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf)</td></tr>
<tr class="separator:ab3bc759924f6ce0721f5ae5bd5d7a0dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b28e2ed0c70bc8e885f4598e98b3ed6"><td class="memItemLeft" align="right" valign="top">BYTE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#a6b28e2ed0c70bc8e885f4598e98b3ed6">cbufGetByte</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf)</td></tr>
<tr class="separator:a6b28e2ed0c70bc8e885f4598e98b3ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b9d31dc48f99c3cfb026aad490d87d9"><td class="memItemLeft" align="right" valign="top">BYTE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#a0b9d31dc48f99c3cfb026aad490d87d9">cbufGetByte_MACRO</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf)</td></tr>
<tr class="separator:a0b9d31dc48f99c3cfb026aad490d87d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85fc0e968bcea418a292ddfbe588c7bb"><td class="memItemLeft" align="right" valign="top">BYTE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#a85fc0e968bcea418a292ddfbe588c7bb">cbufGetEscapedByte</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf, BYTE *b)</td></tr>
<tr class="separator:a85fc0e968bcea418a292ddfbe588c7bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9444a521104ea2392b4b2e79990b17eb"><td class="memItemLeft" align="right" valign="top">WORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#a9444a521104ea2392b4b2e79990b17eb">cbufGetString</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf, BYTE *pDstArr, WORD size)</td></tr>
<tr class="separator:a9444a521104ea2392b4b2e79990b17eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23b5e718c2dd449298610ea7d9333d60"><td class="memItemLeft" align="right" valign="top">WORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#a23b5e718c2dd449298610ea7d9333d60">cbufGetArray</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf, BYTE *pDstArr, WORD size)</td></tr>
<tr class="separator:a23b5e718c2dd449298610ea7d9333d60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae47d3c25f4f4eb95996ab8f91bd2515"><td class="memItemLeft" align="right" valign="top">WORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#aae47d3c25f4f4eb95996ab8f91bd2515">cbufGetArrayTillByte</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf, BYTE *pDstArr, BYTE value, WORD size)</td></tr>
<tr class="separator:aae47d3c25f4f4eb95996ab8f91bd2515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea030acb25382f54ed304d684b1614d9"><td class="memItemLeft" align="right" valign="top">WORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#aea030acb25382f54ed304d684b1614d9">cbufGetRdArrSize</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf)</td></tr>
<tr class="separator:aea030acb25382f54ed304d684b1614d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e489cc2f6a8d09973fa76fd85c2a676"><td class="memItemLeft" align="right" valign="top">BYTE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#a8e489cc2f6a8d09973fa76fd85c2a676">cbufGetRdArr</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf)</td></tr>
<tr class="separator:a8e489cc2f6a8d09973fa76fd85c2a676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad56769cd53384959977771c1f1fe3529"><td class="memItemLeft" align="right" valign="top">BYTE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#ad56769cd53384959977771c1f1fe3529">cbufPutByte</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf, BYTE b)</td></tr>
<tr class="separator:ad56769cd53384959977771c1f1fe3529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85db23225422115836736bdfb51986fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#a85db23225422115836736bdfb51986fa">cbufPutByteNoCheck</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf, BYTE b)</td></tr>
<tr class="separator:a85db23225422115836736bdfb51986fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce7844e0cdf684a3ca0d47ffaf690ce"><td class="memItemLeft" align="right" valign="top">BYTE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#a8ce7844e0cdf684a3ca0d47ffaf690ce">cbufPutWord</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf, WORD w)</td></tr>
<tr class="separator:a8ce7844e0cdf684a3ca0d47ffaf690ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5984299178eba4ab8f8de13159c3d4e7"><td class="memItemLeft" align="right" valign="top">BYTE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#a5984299178eba4ab8f8de13159c3d4e7">cbufPutByteAscii</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf, BYTE b)</td></tr>
<tr class="separator:a5984299178eba4ab8f8de13159c3d4e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adba91368037807a9509446eb526471bf"><td class="memItemLeft" align="right" valign="top">BYTE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#adba91368037807a9509446eb526471bf">cbufPutByteAsciiHex</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf, BYTE b)</td></tr>
<tr class="separator:adba91368037807a9509446eb526471bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac28dd8f3c542f4151419dc3a0ea8fa9e"><td class="memItemLeft" align="right" valign="top">BYTE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#ac28dd8f3c542f4151419dc3a0ea8fa9e">cbufPutWordAscii</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf, WORD w)</td></tr>
<tr class="separator:ac28dd8f3c542f4151419dc3a0ea8fa9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a907ced88795565ff9ffc6c208667a001"><td class="memItemLeft" align="right" valign="top">BYTE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#a907ced88795565ff9ffc6c208667a001">cbufPutWordAsciiHex</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf, WORD w)</td></tr>
<tr class="separator:a907ced88795565ff9ffc6c208667a001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7886db768e36208bd8ec11a6cfcfcd05"><td class="memItemLeft" align="right" valign="top">BYTE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#a7886db768e36208bd8ec11a6cfcfcd05">cbufShaddowPutByte</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf, BYTE b, WORD putShaddow)</td></tr>
<tr class="separator:a7886db768e36208bd8ec11a6cfcfcd05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f47f9deea38e1136cfce1c4f7e8524"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#ae1f47f9deea38e1136cfce1c4f7e8524">cbufShaddowPutCommit</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf, WORD putShaddow)</td></tr>
<tr class="separator:ae1f47f9deea38e1136cfce1c4f7e8524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec513956e1e3c33e29ec996ae9c9134"><td class="memItemLeft" align="right" valign="top">BYTE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#a5ec513956e1e3c33e29ec996ae9c9134">cbufPutControlChar</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf, BYTE b)</td></tr>
<tr class="separator:a5ec513956e1e3c33e29ec996ae9c9134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea929081c8ff25fa59ee696ac9c406b"><td class="memItemLeft" align="right" valign="top">BYTE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#a5ea929081c8ff25fa59ee696ac9c406b">cbufPutEscapedByte</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf, BYTE b)</td></tr>
<tr class="separator:a5ea929081c8ff25fa59ee696ac9c406b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf805c529e964381d5c1d5e8e98e893d"><td class="memItemLeft" align="right" valign="top">WORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#aaf805c529e964381d5c1d5e8e98e893d">cbufPutString</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf, const char *s)</td></tr>
<tr class="separator:aaf805c529e964381d5c1d5e8e98e893d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7364bd37a4e83828296b92902eb7de68"><td class="memItemLeft" align="right" valign="top">WORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#a7364bd37a4e83828296b92902eb7de68">cbufPutAsciiEscString</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *cbufDst, <a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *cbufSrc, const char *pStrSrc, WORD flags)</td></tr>
<tr class="separator:a7364bd37a4e83828296b92902eb7de68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c0ba7ff14038bfa2f2679c1fbdcf96"><td class="memItemLeft" align="right" valign="top">WORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#ab7c0ba7ff14038bfa2f2679c1fbdcf96">cbufPutStringWait</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf, const char *s)</td></tr>
<tr class="separator:ab7c0ba7ff14038bfa2f2679c1fbdcf96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb51357e524712ba817c7b822c3cdae"><td class="memItemLeft" align="right" valign="top">WORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#aadb51357e524712ba817c7b822c3cdae">cbufPutArray</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf, const BYTE *pSrcArr, WORD size)</td></tr>
<tr class="separator:aadb51357e524712ba817c7b822c3cdae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45d560503f0edcc7d5bdb906e63adf7c"><td class="memItemLeft" align="right" valign="top">WORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#a45d560503f0edcc7d5bdb906e63adf7c">cbufPutArrayWait</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf, const BYTE *pSrcArr, WORD size)</td></tr>
<tr class="separator:a45d560503f0edcc7d5bdb906e63adf7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab743e216fb9c7108223f01395757bac9"><td class="memItemLeft" align="right" valign="top">WORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#ab743e216fb9c7108223f01395757bac9">cbufMove</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBufSrc, <a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBufDst)</td></tr>
<tr class="separator:ab743e216fb9c7108223f01395757bac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc6c70941aaca490c86433ee87ecea6"><td class="memItemLeft" align="right" valign="top">WORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#a8dc6c70941aaca490c86433ee87ecea6">cbufGetWrArrSize</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf)</td></tr>
<tr class="separator:a8dc6c70941aaca490c86433ee87ecea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bd77db38205402ed87cf138d2df8f6e"><td class="memItemLeft" align="right" valign="top">BYTE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#a3bd77db38205402ed87cf138d2df8f6e">cbufGetWrArr</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf)</td></tr>
<tr class="separator:a3bd77db38205402ed87cf138d2df8f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19b647cec69d4f420e08a08c8422d673"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#a19b647cec69d4f420e08a08c8422d673">cbufUpdatePut</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf, WORD n)</td></tr>
<tr class="separator:a19b647cec69d4f420e08a08c8422d673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a604e383451f246eb00206cc337291344"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#a604e383451f246eb00206cc337291344">cbufGetError</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf)</td></tr>
<tr class="separator:a604e383451f246eb00206cc337291344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2cd70ec6be5ecca82738ec3b5a2b1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#a0c2cd70ec6be5ecca82738ec3b5a2b1f">cbufClearError</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf)</td></tr>
<tr class="separator:a0c2cd70ec6be5ecca82738ec3b5a2b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f4f447d3d2c50500a607740d635560"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#a46f4f447d3d2c50500a607740d635560">cbufIsPacket</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf)</td></tr>
<tr class="separator:a46f4f447d3d2c50500a607740d635560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d23bc5d7b35391fc96fcc3fa027287"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#a00d23bc5d7b35391fc96fcc3fa027287">cbufIsPacketLarge</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf)</td></tr>
<tr class="separator:a00d23bc5d7b35391fc96fcc3fa027287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00a8ce0f071a8a966bc66294fdd9081"><td class="memItemLeft" align="right" valign="top">WORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#af00a8ce0f071a8a966bc66294fdd9081">cbufHasWholePacket</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf)</td></tr>
<tr class="separator:af00a8ce0f071a8a966bc66294fdd9081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce13d16c59e3a6e02d750c462d9aad6"><td class="memItemLeft" align="right" valign="top">WORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#a5ce13d16c59e3a6e02d750c462d9aad6">cbufPacketStrcmp</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf, const char *str)</td></tr>
<tr class="separator:a5ce13d16c59e3a6e02d750c462d9aad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b52b1b15b260d804dc39dbb2a5886f"><td class="memItemLeft" align="right" valign="top">WORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#ad4b52b1b15b260d804dc39dbb2a5886f">cbufGetFreeForPacket</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf)</td></tr>
<tr class="separator:ad4b52b1b15b260d804dc39dbb2a5886f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a537f0230c389a8c3aca5bca45d98557e"><td class="memItemLeft" align="right" valign="top">WORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#a537f0230c389a8c3aca5bca45d98557e">cbufGetContiguousPacket</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf, BYTE **ppData)</td></tr>
<tr class="separator:a537f0230c389a8c3aca5bca45d98557e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc537ea5067bd52e8260ffc3ac47d493"><td class="memItemLeft" align="right" valign="top">WORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#adc537ea5067bd52e8260ffc3ac47d493">cbufGetPacketDataSize</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf)</td></tr>
<tr class="separator:adc537ea5067bd52e8260ffc3ac47d493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6217f5ddf36757340831b3b6524c95b1"><td class="memItemLeft" align="right" valign="top">BYTE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#a6217f5ddf36757340831b3b6524c95b1">cbufPeekPacketByte</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf)</td></tr>
<tr class="separator:a6217f5ddf36757340831b3b6524c95b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb0634abd6f6e886a005edfe91997aa"><td class="memItemLeft" align="right" valign="top">WORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#afdb0634abd6f6e886a005edfe91997aa">cbufPeekPacketDataSize</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf)</td></tr>
<tr class="separator:afdb0634abd6f6e886a005edfe91997aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fd6a9aa372df330bd88444bb0ee61ac"><td class="memItemLeft" align="right" valign="top">WORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#a4fd6a9aa372df330bd88444bb0ee61ac">cbufPutPacket</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf, const BYTE *pSrcArr, WORD size)</td></tr>
<tr class="separator:a4fd6a9aa372df330bd88444bb0ee61ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ff25acfdec531e69b8437abb11b720"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nz__circular_buffer_8h.html#a41ff25acfdec531e69b8437abb11b720">cbufRemovePacket</a> (<a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *pBuf)</td></tr>
<tr class="separator:a41ff25acfdec531e69b8437abb11b720"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file defines a Circular Buffer interface. </p>
<dl class="section author"><dt>Author</dt><dd><a href="www.modtronix.com">Modtronix Engineering</a> </dd></dl>
<dl class="section user"><dt>Compiler:</dt><dd>MPLAB XC16 compiler</dd></dl>
<h1><a class="anchor" id="nz_circularBuffer_desc"></a>
Description</h1>
<p>Circular buffers form a very important part of the Netcruzer Library. They are used for many of the modules contained in the library, and provide a consistent way for exchanging data between modules. In it's simplest form it is a "first in, first out" BYTE buffer. It provides the basic functions for reading and writing data from and to the buffer. But also contains many additional, more advanced functions.</p>
<p>This file defines a Circular Buffer interface. The implementation has to be done in a separate c file by creating instances of these functions. The Netcruzer library contains two implementations:</p>
<ul>
<li>nz_circularBufferStd.c, this is a default implementation for creating circular buffers of any size.</li>
<li>nz_circularBufferPwr2.c, this is a more efficient implementation, with the condition that the size has to be a power of 2 value (4,8,16,32,64,128...). Most examples and projects use the nz_circularBufferPwr2.c implementation.</li>
</ul>
<h1><a class="anchor" id="nz_circularBuffer_conf"></a>
Configuration</h1>
<p>The following defines are used to configure this module, and should be placed in projdefs.h. Note that all items marked [-DEFAULT-] are defaults, and do not have to be placed in projdefs.h if they contain desired configuration! For details, see <a class="el" href="group__info__conf__proj.html">Project Configuration</a>. </p>
<div class="fragment"><div class="line"><span class="comment">// *********************************************************************</span></div>
<div class="line"><span class="comment">// ------- Circular Buffer Configuration (nz_circularBuffer.h) ---------</span></div>
<div class="line"><span class="comment">// *********************************************************************</span></div>
<div class="line"><span class="comment">//Specifies what circular buffer is used. Ensure only one of the following is uncommented. If none selected, nz_circularBufferStd is used</span></div>
<div class="line"><span class="comment">//#define    CIRBUF_USE_CIRCULAR_BUFFER_STD                 //Use nz_circularBufferStd</span></div>
<div class="line"><span class="preprocessor">#define     CIRBUF_USE_CIRCULAR_BUFFER_PWR2                 //Use nz_circularBufferPwrs</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="comment">//Optimize for size, not speed!</span></div>
<div class="line"><span class="preprocessor">#define     CIRBUF_OPTIMIZE_SIZE</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="comment">//Configure buffer NOT to supports packets - define to create smaller code when packets not used.</span></div>
<div class="line"><span class="comment">//#define   CIRBUF_DISABLE_PACKETS</span></div>
<div class="line"></div>
<div class="line"><span class="comment">//Configure buffer NOT to supports large packets (65,279 bytes, standard is 254) - define to create smaller code when large packets not used.</span></div>
<div class="line"><span class="comment">//#define   CIRBUF_DISABLE_LARGE_PACKET</span></div>
<div class="line"></div>
<div class="line"><span class="comment">//Defines minimum size allowed for a circular buffer. Default is 8</span></div>
<div class="line"><span class="comment">//#define   CIRBUF_MIN_SIZE                     ( 8 )</span></div>
<div class="line"></div>
<div class="line"><span class="comment">//Disable all MARCO_xxx functions. Uncomment this line for smaller code. Comment this line for faster, larger code.</span></div>
<div class="line"><span class="comment">//#define   CIRBUF_DISABLE_ALL_MACRO_FUNCTIONS</span></div>
<div class="line"></div>
<div class="line"><span class="comment">//Standard Escape Character</span></div>
<div class="line"><span class="preprocessor">#define     CIRBUF_ESC_CHAR                     ( &#39;^&#39; )     //[-DEFAULT-]</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="comment">//Small code saving by using cbufPutByte() for cbufPutByteNoCheck(). Not enabled by default!</span></div>
<div class="line"><span class="comment">//#define   CIRBUF_USE_PUTBYTE_FOR_PUTBYTENOCHECK</span></div>
</div><!-- fragment --><h1><a class="anchor" id="nz_circularBuffer_usage"></a>
Usage</h1>
<p>To use a circular buffer, the following must be done:</p>
<ul>
<li>Copy the <a class="el" href="nz__circular_buffer_8h.html#nz_circularBuffer_conf">Configuration</a> section above (from <a class="el" href="nz__circular_buffer_8h.html" title="This file defines a Circular Buffer interface. ">nz_circularBuffer.h</a>) to the projdefs.h file.</li>
<li>In this "Configuration" section, change any default values if required (if default values should be used, define is not required in projdefs.h).</li>
<li>Add a default implementation c file to the MPLAB project, like nz_circularBufferPwr2.c for example.</li>
<li>Add nz_helpers.c to the MPLAB project.</li>
<li><b>All DONE!</b> The functions defined in this file can now be used in the project.</li>
</ul>
<h1><a class="anchor" id="nz_circularBuffer_type"></a>
Buffer Type</h1>
<p>When creating a circular buffer, the type and format is specified. When working with Circular Buffers, the buffer's type can be obtained with the <a class="el" href="nz__circular_buffer_8h.html#a3eccf756cb70b14b4ef500acb66b622e">cbufGetType()</a> function. There are two main buffer types, streaming and packet. For a standard data buffer, with no formatting, a streaming buffer with no formatting should be created. This is done by the following code: </p>
<div class="fragment"><div class="line"><a class="code" href="struct___c_i_r_b_u_f.html">CIRBUF</a> cbufTest;    <span class="comment">//CIRCUF structure</span></div>
<div class="line">BYTE   bufTest[32]; <span class="comment">//Byte array for buffer data</span></div>
<div class="line"><a class="code" href="nz__circular_buffer_8h.html#a52ea37f827a113e2451b36e8ce603f2b">cbufInit</a>(&amp;cbufTest, bufTest, <span class="keyword">sizeof</span>(bufTest), <a class="code" href="nz__circular_buffer_8h.html#ab484ba359723d9b5135d8a6d4e64878b">CIRBUF_FORMAT_NONE</a> | <a class="code" href="nz__circular_buffer_8h.html#add444d24fc4e31afa0b16aa26b0df054">CIRBUF_TYPE_STREAMING</a>);</div>
</div><!-- fragment --><h2><a class="anchor" id="nz_circularBuffer_type_streaming"></a>
Streaming Type</h2>
<p>This type of buffer is created by passing the CIRBUF_TYPE_STREAMING define to the <a class="el" href="nz__circular_buffer_8h.html#a52ea37f827a113e2451b36e8ce603f2b">cbufInit()</a> function. It creates a simple "first in, first out" type buffer, for reading and writing single bytes. There is no formatting! Bytes are added with <a class="el" href="nz__circular_buffer_8h.html#ad56769cd53384959977771c1f1fe3529">cbufPutByte()</a>, and removed with <a class="el" href="nz__circular_buffer_8h.html#a6b28e2ed0c70bc8e885f4598e98b3ed6">cbufGetByte()</a> functions.</p>
<h2><a class="anchor" id="nz_circularBuffer_type_packet"></a>
Packet Type</h2>
<p>This type of buffer is created by passing the CIRBUF_TYPE_PACKET define to the <a class="el" href="nz__circular_buffer_8h.html#a52ea37f827a113e2451b36e8ce603f2b">cbufInit()</a> function. A packet type buffer groups data together in packets, with a maximum data size of 254 bytes. It has the following format:<br/>
 [Size 8-bit][Data]</p>
<ul>
<li><b>size</b>: Is the 8-bit size of data to follow</li>
<li><b>data</b>: The packet data.</li>
</ul>
<p>Various packet functions are provided for reading and writing data from and to the buffer in packet format. Some of them are:<br/>
 <a class="el" href="nz__circular_buffer_8h.html#a46f4f447d3d2c50500a607740d635560">cbufIsPacket()</a>, <a class="el" href="nz__circular_buffer_8h.html#af00a8ce0f071a8a966bc66294fdd9081">cbufHasWholePacket()</a>, <a class="el" href="nz__circular_buffer_8h.html#a6217f5ddf36757340831b3b6524c95b1">cbufPeekPacketByte()</a>, <a class="el" href="nz__circular_buffer_8h.html#afdb0634abd6f6e886a005edfe91997aa">cbufPeekPacketDataSize()</a>, <br/>
 <a class="el" href="nz__circular_buffer_8h.html#a4fd6a9aa372df330bd88444bb0ee61ac">cbufPutPacket()</a>, <a class="el" href="nz__circular_buffer_8h.html#a537f0230c389a8c3aca5bca45d98557e">cbufGetContiguousPacket()</a>....</p>
<h2><a class="anchor" id="nz_circularBuffer_type_large_packet"></a>
Large Packet Type</h2>
<p>This type of buffer is created by passing the CIRBUF_TYPE_LARGE_PACKET define to the <a class="el" href="nz__circular_buffer_8h.html#a52ea37f827a113e2451b36e8ce603f2b">cbufInit()</a> function. Same as CIRBUF_TYPE_PACKET, but the packet has a much larger possible data size. Data is grouped data together in packets, with a maximum data size of 65,279 bytes. It has the following format:<br/>
 [Size 16-bit][Data] = [size MSB][size LSB][data]</p>
<ul>
<li><b>size</b>: Is the 16-bit size of data to follow. Fist byte (cbufPeekByte(pBuf)) is MSB part of size. If first byte is 0xFF, it is a dummy packet till end of contiguous buffer space. This is used to fill buffer if last part of buffer is too small to hold a packet. Buffer is filled with dummy packet, and packet is written to contiguous data space at beginning of buffer.</li>
<li><b>data</b>: The packet data.</li>
</ul>
<h1><a class="anchor" id="nz_circularBuffer_format"></a>
Buffer Format</h1>
<p>When creating a circular buffer, four formatting types can be specified. The buffer formatting will influence the data provided to, and obtained from certain functions. When working with Circular Buffers, the buffer's format can be obtained with the <a class="el" href="nz__circular_buffer_8h.html#a4e58233528209d1336254424c386695f">cbufGetFormat()</a> function.</p>
<h2><a class="anchor" id="nz_circularBuffer_format_none"></a>
No Format</h2>
<p>Is created by passing the CIRBUF_FORMAT_NONE constant to the <a class="el" href="nz__circular_buffer_8h.html#a52ea37f827a113e2451b36e8ce603f2b">cbufInit()</a> function.<br/>
 Buffer contains <b>binary data</b>. No formatting is provided by any functions.</p>
<h2><a class="anchor" id="nz_circularBuffer_format_bin"></a>
Binary Format</h2>
<p>Is created by passing the CIRBUF_FORMAT_BIN constant to the <a class="el" href="nz__circular_buffer_8h.html#a52ea37f827a113e2451b36e8ce603f2b">cbufInit()</a> function.<br/>
 Buffer contains <b>binary data</b>. No conversion is done to data read and written from and to the buffer.</p>
<h2><a class="anchor" id="nz_circularBuffer_format_bin_esc"></a>
Binary Format, with Escape Sequence</h2>
<p>Is created by passing the CIRBUF_FORMAT_BIN_ESC constant to the <a class="el" href="nz__circular_buffer_8h.html#a52ea37f827a113e2451b36e8ce603f2b">cbufInit()</a> function.<br/>
 Buffer contains <b>binary data</b>. This is the same as the <b>Binary Format</b> buffer, but provides additional functionality for embedding "control characters" in the data. The following additional functions are provided: </p>
<div class="fragment"><div class="line">- <a class="code" href="nz__circular_buffer_8h.html#a0e4322c29348df4805f2ca4c837b9031">cbufGetEscapedSizeRequired</a>()</div>
<div class="line">- <a class="code" href="nz__circular_buffer_8h.html#a4b796c5210baef1474158edcb0e8a4df">cbufGetEscapeCharacter</a>()</div>
<div class="line">- <a class="code" href="nz__circular_buffer_8h.html#a85fc0e968bcea418a292ddfbe588c7bb">cbufGetEscapedByte</a>()</div>
<div class="line">- <a class="code" href="nz__circular_buffer_8h.html#a5ea929081c8ff25fa59ee696ac9c406b">cbufPutEscapedByte</a>()</div>
<div class="line">- <a class="code" href="nz__circular_buffer_8h.html#a5ec513956e1e3c33e29ec996ae9c9134">cbufPutControlChar</a>()</div>
</div><!-- fragment --><p> The '^' character is the default "escape character". It is used to add "control characters" to the buffer. A "control character" is preceded by the '^' character. Two '^' characters following each other represents a single '^' character. The default "escape character" can be changed by adding the CIRBUF_ESC_CHAR define to the projdefs.h file (see <a class="el" href="nz__circular_buffer_8h.html#nz_circularBuffer_conf">Configuration</a>).</p>
<ul>
<li>It is recommended to use <b>lower case</b> characters 'a' to 'z' for "control characters".</li>
<li>It is recommended to use a "not too often" used ASCII character for the "escape character".</li>
</ul>
<p>The following functions provide additional functionality for writing "ASCII formatted strings". </p>
<div class="fragment"><div class="line">- <a class="code" href="nz__circular_buffer_8h.html#a7364bd37a4e83828296b92902eb7de68">cbufPutAsciiEscString</a>()</div>
</div><!-- fragment --><p> The given string will be encoded, and stored in binary format in the buffer.</p>
<p>The "escape sequences" are:<br/>
 </p>
<table class="doxtable">
<tr>
<th>Escape<br/>
 Sequence </th><th>Description  </th></tr>
<tr>
<td><b>^^</b> </td><td>Two "escape characters" represents a single '^' character. </td></tr>
<tr>
<td><b>^x</b> </td><td>Use this format to represent a "control character". For example '^s' could be used to represent an I2C bus Start condition. </td></tr>
</table>
<p>An example of this type of buffer would be for sending I2C data. The I2C bus can put START and STOP conditions on the bus in addition to normal data. The '^s' and '^p' "escape sequences" can be use to represent Start and Stop commands. For example, to put a START condition on the bus, followed by "Hello", followed by the STOP condition, the following bytes should be added to the buffer:<br/>
 '<b>^</b>', '<b>s</b>', '<b>H</b>', '<b>e</b>', '<b>l</b>', '<b>l</b>', '<b>o</b>', '<b>^</b>', '<b>p</b>'</p>
<h2><a class="anchor" id="nz_circularBuffer_format_ascii"></a>
ASCII Format</h2>
<p>Is created by passing the CIRBUF_FORMAT_ASCII constant to the <a class="el" href="nz__circular_buffer_8h.html#a52ea37f827a113e2451b36e8ce603f2b">cbufInit()</a> function.<br/>
 The buffer contain readable <b>ASCII characters</b> (human readable ASCII format):</p>
<ul>
<li>Bytes are represented as two-digit, upper case hex characters.</li>
<li>Strings can be inserted by enclosing them with single quotation marks(').</li>
</ul>
<p>No special formatting is provided by any functions.</p>
<p>The buffer has the following format:<br/>
 </p>
<table class="doxtable">
<tr>
<th>Format </th><th>Description  </th></tr>
<tr>
<td><b>XX</b> </td><td>Two upper case characters representing a single byte (hex value). </td></tr>
<tr>
<td><b>'</b> </td><td>Enclose string with single quotes. A double ' character will not end the string, but represents a single ' character. </td></tr>
</table>
<p>The following example shows how to represent 3 bytes (0x50, 0xC0 and 0xFA) with an "ASCII formatted string": </p>
<div class="fragment"><div class="line">50C0FA</div>
</div><!-- fragment --><p> It is stored in the buffer as <b>6</b> characters, and represents the following <b>3</b> bytes = 0x50, 0xC0, 0xFA.</p>
<p>The following example shows how to represent the same 3 bytes as above (0x50, 0xC0 and 0xFA), with a string (Hello) added to it: </p>
<div class="fragment"><div class="line">50C0FA<span class="stringliteral">&#39;Hello&#39;</span></div>
</div><!-- fragment --><p> It is stored in the buffer as <b>13</b> characters, and represents the following <b>8</b> bytes:<br/>
 0x50, 0xC0, 0xFA, 'H', 'e', 'l', 'l', 'o'</p>
<h2><a class="anchor" id="nz_circularBuffer_format_ascii_esc"></a>
ASCII Format, with Escape Sequence</h2>
<p>Is created by passing the CIRBUF_FORMAT_ASCII_ESC constant to the <a class="el" href="nz__circular_buffer_8h.html#a52ea37f827a113e2451b36e8ce603f2b">cbufInit()</a> function.<br/>
 This is the same as the <b>ASCII Format</b> buffer, but provides additional functionality for embedding "control characters" in the data.</p>
<ul>
<li>Bytes are represented as two-digit, upper case hex characters.</li>
<li>Strings can be inserted by enclosing them with single quotation marks(').</li>
<li>"Control characters" are represented by a lower case character 'a' to 'z'</li>
<li><b>Additionally</b> "Control characters" can be inserting by using the "escape character", followed by any ASCII character</li>
<li>'s' an 'p' control characters represent the start and stop of a message.</li>
</ul>
<p>For lower case control characters in the range 'a' to 'z', no "escape character" is required! For "control characters" outside this range, an "escape sequence" is required! It is recommended always using lower case "control characters"!</p>
<p>The buffer has the following format:<br/>
 </p>
<table class="doxtable">
<tr>
<th>Format </th><th>Description  </th></tr>
<tr>
<td><b>XX</b> </td><td>Two upper case characters representing a single byte (hex value). </td></tr>
<tr>
<td><b>c</b> </td><td>Lower case character 'a' to 'z' represents a "control character". </td></tr>
<tr>
<td><b>s</b>, <b>p</b> </td><td>'s' an 'p' control characters represent the start and stop of a message. </td></tr>
<tr>
<td><b>^^</b> </td><td>Two "escape characters" represents a single '^' character. </td></tr>
<tr>
<td><b>^x</b> </td><td>Use this format to represent a "control character". For example '^s' could be used to represent an I2C bus Start condition. </td></tr>
<tr>
<td><b>'</b> </td><td>Enclose string with single quotes. A double ' character will not end the string, but represents a single ' character. </td></tr>
</table>
<p>The following example shows how to represent 3 bytes (0x50, 0xC0 and 0xFA) with an "ASCII formatted string": </p>
<div class="fragment"><div class="line">50C0FA</div>
</div><!-- fragment --><p> It is stored in the buffer as <b>6</b> characters, and represents the following <b>3</b> bytes = 0x50, 0xC0, 0xFA.</p>
<p>The following example shows how to represent the same 3 bytes as above (0x50, 0xC0 and 0xFA) with an "ASCII formatted string". In addition it adds a 's' and 'p' control character to the front and back of the 3 bytes: </p>
<div class="fragment"><div class="line">s50C0FAp</div>
</div><!-- fragment --><p> It is stored in the buffer as <b>8</b> characters, and represents the following <b>5</b> bytes<br/>
: <em>'s'(Control Character)</em>, 0x50, 0xC0, 0xFA, <em>'p'(Control Character)</em></p>
<p>The following example shows how to represent the same 3 bytes as above (0x50, 0xC0 and 0xFA) with an "ASCII formatted string". In addition it adds a 'Z' and 'p' control character to the front and back of the 3 bytes. <b>NOTE</b> that because 'Z' is not lower case, it need to be written as an "escape sequence"!: </p>
<div class="fragment"><div class="line">^Z50C0FAp</div>
</div><!-- fragment --><p> It is stored in the buffer as <b>9</b> characters, and represents the following <b>5</b> bytes<br/>
: <em>'Z'(Control Character)</em>, 0x50, 0xC0, 0xFA, <em>'p'(Control Character)</em></p>
<p>The following example shows how to represent the same 3 bytes as above (0x50, 0xC0 and 0xFA), with a string (Hello) added to it: </p>
<div class="fragment"><div class="line">50C0FA<span class="stringliteral">&#39;Hello&#39;</span></div>
</div><!-- fragment --><p> It is stored in the buffer as <b>13</b> characters, and represents the following <b>8</b> bytes:<br/>
 0x50, 0xC0, 0xFA, 'H', 'e', 'l', 'l', 'o'</p>
<p>The following example shows how to represent the same 3 bytes as above (0x50, 0xC0 and 0xFA), with a string (Hi) added to it. It also adds a 's' and 'p' control character to the front and back of the data: </p>
<div class="fragment"><div class="line">s50C0FA<span class="stringliteral">&#39;Hi&#39;</span>p</div>
</div><!-- fragment --><p> It is stored in the buffer as <b>12</b> characters, and represents the following <b>7</b> bytes<br/>
: <em>'s'(Control Character)</em>, 0x50, 0xC0, 0xFA, 'H', 'i', <em>'p'(Control Character)</em></p>
<h1><a class="anchor" id="nz_circularBuffer_lic"></a>
Software License Agreement</h1>
<p>The software supplied herewith is owned by Modtronix Engineering, and is protected under applicable copyright laws. The software supplied herewith is intended and supplied to you, the Company customer, for use solely and exclusively on products manufactured by Modtronix Engineering. The code may be modified and can be used free of charge for commercial and non commercial applications. All rights are reserved. Any use in violation of the foregoing restrictions may subject the user to criminal sanctions under applicable laws, as well as to civil liability for the breach of the terms and conditions of this license.</p>
<p>THIS SOFTWARE IS PROVIDED IN AN 'AS IS' CONDITION. NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.</p>
<p>File History</p>
<p>2010-10-11, David H. (DH):</p>
<ul>
<li>Initial version </li>
</ul>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a82a632425a9c5a59c3b6c3c28630e028"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ASCIIESC_ADD_S_AND_P&#160;&#160;&#160;0x0001</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag instructing <a class="el" href="nz__circular_buffer_8h.html#a7364bd37a4e83828296b92902eb7de68">cbufPutAsciiEscString()</a> function to adds a 's' and 'p' control character to front and back of destination. </p>

</div>
</div>
<a class="anchor" id="a4b796c5210baef1474158edcb0e8a4df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define cbufGetEscapeCharacter</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pBuf)</td><td></td>
          <td>&#160;&#160;&#160;(<a class="el" href="nz__circular_buffer_8h.html#a635051e93faa8d2c27cb0d480cf34a51">CIRBUF_ESC_CHAR</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the "escape characters". The default escape character is '^'. This can be changed by defining CIRBUF_ESC_CHAR in the projdefs.h file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the escape character, is '^' by default. </dd></dl>

</div>
</div>
<a class="anchor" id="a23271dae445b440574139341e3cae1ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define cbufHasSpace</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pBuf)</td><td></td>
          <td>&#160;&#160;&#160;(<a class="el" href="nz__circular_buffer_8h.html#aaa470ac2cbb00d8a031a8f8062f261bd">cbufIsFull</a>(pBuf)==0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if the given buffer is not full. Has space for adding data.</p>
<p>For <b>Multi Threaded Applications</b>, call from "PUT context".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the given buffer has data. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="usb_2device__m_i_d_i__l_c_d_2main_8c-example.html#a1">usb/device_MIDI_LCD/main.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a635051e93faa8d2c27cb0d480cf34a51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CIRBUF_ESC_CHAR&#160;&#160;&#160;'^'</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For packet buffers, this causes packet to ONLY be placed into contiguous data space in the buffer. If a packet is added to the buffer, a check is done to see if there is enough contiguous space at the end of the buffer to add the packet. If not, a dummy packet (MSB byte of size = 0xff) is written to the end of the buffer (fills the end of buffer, and the packet is written at the start of the buffer. This will cause space to be lost in a buffer, but greatly simplifies code, seeing that packets are always located in contiguous data space. </p>

</div>
</div>
<a class="anchor" id="a89bb65ab059e789c017f7facb05e8fee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CIRBUF_FORMAT_ASCII&#160;&#160;&#160;0x0004</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Buffer is in ASCII (plain text) format </p>

</div>
</div>
<a class="anchor" id="a9a4f6c1a0c3f04f74721fad372129b24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CIRBUF_FORMAT_ASCII_ESC&#160;&#160;&#160;0x0008</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Buffer is in ASCII format (plain text), with Escape sequence (Control Character) processing. The '^' is the default escape character. Standard Two '^' characters following each other represent a single '^' character. </p>

</div>
</div>
<a class="anchor" id="a8cdac497b4733517fe99319636dffe30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CIRBUF_FORMAT_BIN&#160;&#160;&#160;0x000C</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Buffer is in plain Binary format. No processing of the data is done. </p>

</div>
</div>
<a class="anchor" id="a294c2ccacd00786d3fa59b327f00240b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CIRBUF_FORMAT_BIN_ESC&#160;&#160;&#160;0x0010</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Buffer is in plain Binary format, with Escape sequence processing. The '^' is the default escape character. Two '^' characters following each other represent a single '^' character. Exact processing of Escape sequence depends on buffer type, and how it processes them. For example, an I2C buffer could interpret '^S' as a "Bus Start condition", and '^P' as a "Bus Stop condition". </p>

</div>
</div>
<a class="anchor" id="ab484ba359723d9b5135d8a6d4e64878b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CIRBUF_FORMAT_NONE&#160;&#160;&#160;0x0000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Buffer has no formatting. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="cirbuf_demo1_2main_8c-example.html#a2">cirbuf_demo1/main.c</a>, and <a class="el" href="cirbuf_packet_demo_2main_8c-example.html#a2">cirbuf_packet_demo/main.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ab323182818bc390d34ee553b25a93881"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CIRBUF_TYPE_LARGE_PACKET&#160;&#160;&#160;0x0003</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Large Packet buffer type, maximum 65,279 bytes long. Each packet added has the format:<br/>
 [Size 16-bit][Data] = [size MSB][size LSB][data]</p>
<ul>
<li><b>size</b>: Is the 16-bit size of data to follow. Fist byte (cbufPeekByte(pBuf)) is MSB part of size. If first byte is 0xFF, it is a dummy packet till end of contiguous buffer space. This is used to fill buffer if last part of buffer is too small to hold a packet. Buffer is filled with dummy packet, and packet is written to contiguous data space at beginning of buffer.</li>
<li><b>data</b>: The data</li>
</ul>
<p>Same as CIRBUF_TYPE_PACKET, but larger possible data. Get size of packet (data part, whole packet is one more) with bufGetLargePacketSize(CIRBUF_RX_xxx) function </p>

</div>
</div>
<a class="anchor" id="aa8ffc8279962dab7ae703972908d4623"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CIRBUF_TYPE_PACKET&#160;&#160;&#160;0x0001</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Packet buffer type, maximum 254 bytes long. Each packet added has the format:<br/>
 [Size 8-bit][Data]</p>
<ul>
<li><b>size</b>: Is the 8-bit size of data to follow</li>
<li><b>data</b>: The data</li>
</ul>
<p>New packet is only added if there is enough space, ensuring buffer does not get corrupted. If no space, low level code responsible for adding packet might send failure message to sender, requesting it is sent again at a later stage. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="cirbuf_packet_demo_2main_8c-example.html#a3">cirbuf_packet_demo/main.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="add444d24fc4e31afa0b16aa26b0df054"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CIRBUF_TYPE_STREAMING&#160;&#160;&#160;0x0000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default buffer type. Streaming buffer, there is no formatting! Bytes are added with <a class="el" href="nz__circular_buffer_8h.html#ad56769cd53384959977771c1f1fe3529">cbufPutByte()</a>, and removed with <a class="el" href="nz__circular_buffer_8h.html#a6b28e2ed0c70bc8e885f4598e98b3ed6">cbufGetByte()</a> functions. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="cirbuf_demo1_2main_8c-example.html#a3">cirbuf_demo1/main.c</a>.</dd>
</dl>
</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="abe1952d063f6dc2949499653d4ad778c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct___c_i_r_b_u_f.html">_CIRBUF</a>  <a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Circular Buffer Structure, for buffers with maximum size of 65279. Exactly the same as CIRBUF structure, but flagBits.bSizePower2 flag must be clear. Use bufXxx functions with this structure. bufXxx functions always work, and buffXxx are optimzed functions for when buffer size is a power of 2. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a0c2cd70ec6be5ecca82738ec3b5a2b1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cbufClearError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears all error flags.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7770b7064483faee83b2711323d2c685"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cbufEmpty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Empty the given buffer. Any data contained in the buffer is lost.</p>
<p>For "Packet" buffer, do not use this function. When calling <a class="el" href="nz__circular_buffer_8h.html#a4fd6a9aa372df330bd88444bb0ee61ac">cbufPutPacket()</a>, and there is no space AND 2 contiguous blocks, write dummy packet. This will cause the next bufGetXxx function to remove dummy packet, and reset buffer to PUT=GET=0</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="cirbuf_demo1_2main_8c-example.html#a9">cirbuf_demo1/main.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a526e2623362c316b486a0619319a9ec7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WORD cbufFindByte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WORD&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find first occurance of given byte. The offset in the buffer is returned. For example, if the string is "Name=Mark", and we call cbufFindByte(pBuf, 0, '='), it will return 4 (index of =).</p>
<p>For <b>Multi Threaded Applications</b>, call from "GET context".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure</td></tr>
    <tr><td class="paramname">offset</td><td>Offset to start the search from, 0 is start of buffer. NOT SUPPORTED YET, but will be in future!</td></tr>
    <tr><td class="paramname">value</td><td>Byte to search forl</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Offset of byte, or -1 of not found </dd></dl>

</div>
</div>
<a class="anchor" id="a23b5e718c2dd449298610ea7d9333d60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WORD cbufGetArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE *&#160;</td>
          <td class="paramname"><em>pDstArr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WORD&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies given number of bytes to BYTE array, remove them from source "Circular Buffer", and returns actual number of bytes copied. If returned value is less than given size, all bytes were copies from source, and it didn't have enough bytes.</p>
<p>For <b>Multi Threaded Applications</b>, call from "GET context".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to source CIRBUF structure, that data is copied from </td></tr>
    <tr><td class="paramname">pDstArr</td><td>Pointer to destination BYTE array </td></tr>
    <tr><td class="paramname">size</td><td>Maximum number of bytes to copy. Could be less if pBuf contains less</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns number of bytes added to destination array. </dd></dl>

</div>
</div>
<a class="anchor" id="aae47d3c25f4f4eb95996ab8f91bd2515"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WORD cbufGetArrayTillByte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE *&#160;</td>
          <td class="paramname"><em>pDstArr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WORD&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies bytes from given source "Circular Buffer" (and removed them) to destination "Byte Array" until:</p>
<ul>
<li>A byte with value given in "value" parameter is found (matching byte ALSO COPIED)</li>
<li>End of source "Circular Buffer" reached The actual number of bytes copied is returned.</li>
</ul>
<p>These are the ONLY conditions under which this functions removes bytes from the source "Circular Buffer" (as given by return value)!</p>
<p>The following will return -1, and not remove anything from source "Circular Buffer":</p>
<ul>
<li>Given "size" is exceeded</li>
<li>Given byte ("value") was not found</li>
<li>End of source "Circular Buffer" not reached <br/>
!!!! IMPORTANT !!!!<br/>
 A side affect is that bytes will still be copied to given destination "Byte Array" (pDstArr), but nothing is removed from source "Circular Buffer"!</li>
</ul>
<p>Some examples: <br/>
If the string is "Name=Value", and we call cbufGetArrayTillByte(pBuf, pDstArr, '=', 20): <br/>
- The string "Name=" (5 bytes) will be removed from pBuf, and copied to pDstArr. Returns 5</p>
<p><br/>
If the string is "Name=Value", and we call cbufGetArrayTillByte(pBuf, pDstArr, '=', 3): <br/>
- NOTHING is removed from pBuf! The string "Nam" (3 bytes) is however still copied to pDstArr. Returns -1</p>
<p><br/>
If the string is "Value", and we call cbufGetArrayTillByte(pBuf, pDstArr, '&amp;', 20): <br/>
- The string "Value" (5 bytes) will be removed from pBuf, and copied to pDstArr. Returns 5</p>
<p>For <b>Multi Threaded Applications</b>, call from "GET context".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to source CIRBUF structure, that data is copied from </td></tr>
    <tr><td class="paramname">pDstArr</td><td>Pointer to destination BYTE array </td></tr>
    <tr><td class="paramname">value</td><td>Byte to search for </td></tr>
    <tr><td class="paramname">size</td><td>Maximum number of bytes to copy to pDstArr.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns number of bytes copied to destination array and removed from source buffer, or -1 if nothing removed. NOTE that if -1 returned, bytes are still copied to destination array, but nothing is removed from source buffer </dd></dl>

</div>
</div>
<a class="anchor" id="a6b28e2ed0c70bc8e885f4598e98b3ed6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BYTE cbufGetByte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets a byte from the Buffer, and removes it from buffer.</p>
<dl class="section user"><dt>Pre-Condition:</dt><dd><a class="el" href="nz__circular_buffer_8h.html#aee28b1631393336e0bcda4901f0fea95">cbufIsEmpty()</a> must have been called to confirm the buffer has data!</dd></dl>
<p>For <b>Multi Threaded Applications</b>, call from "GET context".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the next byte in the given buffer. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="cirbuf_demo1_2main_8c-example.html#a13">cirbuf_demo1/main.c</a>, <a class="el" href="uart_debug_demo1_2main_8c-example.html#a5">uart_debug_demo1/main.c</a>, and <a class="el" href="usb_2device__m_i_d_i__l_c_d_2main_8c-example.html#a5">usb/device_MIDI_LCD/main.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a0b9d31dc48f99c3cfb026aad490d87d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BYTE cbufGetByte_MACRO </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets a byte from the Buffer, and removes it from buffer. MACRO version, ONLY use as expression, like "c=cbufGetByte_MACRO(pBuf);" ! !!!! IMPORTANT !!!! Never use in statment, but only on single line. DON'T use like this: if ((i = cbufGetByte(1)) &gt; 1) Use like that: i = cbufGetByte(1);</p>
<dl class="section user"><dt>Pre-Condition:</dt><dd><a class="el" href="nz__circular_buffer_8h.html#aee28b1631393336e0bcda4901f0fea95">cbufIsEmpty()</a> must have been called to confirm the buffer has data!</dd></dl>
<p>For <b>Multi Threaded Applications</b>, call from "GET context".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the next byte in the given buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="a537f0230c389a8c3aca5bca45d98557e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WORD cbufGetContiguousPacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE **&#160;</td>
          <td class="paramname"><em>ppData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if there is a whole packet available to read, and if so, returns it's size and a pointer to it's data. The data is contained in a contiguous block, pointed to by the returned ppData pointer. The returned size is a value from 1 to 254 for a normal "Packet Circular Buffer", and 1-65279 for a large "Packet Circular Buffer". This function does NOT remove any data from the buffer. If the returned data is processed, the packet can be removed by calling the <a class="el" href="nz__circular_buffer_8h.html#a41ff25acfdec531e69b8437abb11b720">cbufRemovePacket()</a> function.</p>
<dl class="section user"><dt>Pre-Condition:</dt><dd>This must be a "Packet Buffer"!</dd></dl>
<p>For <b>Multi Threaded Applications</b>, call from "GET context".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF circular buffer</td></tr>
    <tr><td class="paramname">ppData</td><td>This paramater is updated (output parameter!) with a pointer to the packet's data buffer. The returned size indicates how much data is available to read..</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns size of packet data. A value from 1 to 254 for a normal "Packet Circular Buffer" and 1-65279 for a large "Packet Circular Buffer". Returns 0 if buffer empty, OR does not contain a packet, OR size part of packet not available. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="cirbuf_packet_demo_2main_8c-example.html#a9">cirbuf_packet_demo/main.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a4b57fbfd7719fe18b0cdfa42594f6824"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WORD cbufGetCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets number of bytes available in buffer for reading.</p>
<p>For <b>Multi Threaded Applications</b>, call from "GET context".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns number of bytes available in buffer. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="cirbuf_demo1_2main_8c-example.html#a8">cirbuf_demo1/main.c</a>, and <a class="el" href="cirbuf_packet_demo_2main_8c-example.html#a11">cirbuf_packet_demo/main.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a604e383451f246eb00206cc337291344"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL cbufGetError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the bErrorFull flag. Use the <a class="el" href="nz__circular_buffer_8h.html#a0c2cd70ec6be5ecca82738ec3b5a2b1f">cbufClearError()</a> function to clear the error flag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bErrorFull flag </dd></dl>

</div>
</div>
<a class="anchor" id="a85fc0e968bcea418a292ddfbe588c7bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BYTE cbufGetEscapedByte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets and removes a byte from the Buffer, taking "escape characters" into account. If the read character is an "escape character", a second byte is also read.</p>
<ul>
<li>If this byte is another "escape character", it represents a single character with the same value as the "escape character". This function returns 0, and the read character is returned via the "b" parameter</li>
<li>If this byte is NOT the "escape character", it is a "control character". This function returns 1, and the control character is returned via the "b" parameter</li>
</ul>
<p>For <b>Multi Threaded Applications</b>, call from "GET context".</p>
<dl class="section user"><dt>Pre-Condition:</dt><dd><a class="el" href="nz__circular_buffer_8h.html#a4b57fbfd7719fe18b0cdfa42594f6824">cbufGetCount()</a> must have been called to confirm the buffer has AT LEAST 2 bytes available to read!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure</td></tr>
    <tr><td class="paramname">b</td><td>Pointer to BYTE for returned character. This function will place the returned character in the byte pointed to by this parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 if a normal byte is returned, else 1 if a "control character" is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a0e4322c29348df4805f2ca4c837b9031"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WORD cbufGetEscapedSizeRequired </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WORD&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the buffer size required for the given array, taking "escape characters" into account. The default escape character is '^'. For each of these characters contained in the array, it has to be escaped with a second '^' character. For example, the string "Esc=^" will return 6, even though the string is only 5 characters long. This is how much space is required to add this string to the buffer. It is stored as "Esc=^^" in the buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure</td></tr>
    <tr><td class="paramname">buf</td><td>The buffer containing the array to process</td></tr>
    <tr><td class="paramname">size</td><td>Size of the given buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns number of free bytes available in buffer. This is maximum bytes we can write to buffer </dd></dl>

</div>
</div>
<a class="anchor" id="a4e58233528209d1336254424c386695f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BYTE cbufGetFormat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns this buffer's format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns this buffer's format, is a CIRBUF_FORMAT_XXX constant </dd></dl>

</div>
</div>
<a class="anchor" id="ae0217704752fe13b84a324f4b1a2cd35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WORD cbufGetFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets number of free bytes available in buffer. This is how much space is available for writing.</p>
<p>Do NOT use for "Packet Buffers" (if this buffer has been configured as a "Packet Buffer"). Use <a class="el" href="nz__circular_buffer_8h.html#ad4b52b1b15b260d804dc39dbb2a5886f">cbufGetFreeForPacket()</a> in stead!</p>
<p>For <b>Multi Threaded Applications</b>, call from "PUT context".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns number of free bytes available in buffer. This is maximum bytes we can write to buffer </dd></dl>

</div>
</div>
<a class="anchor" id="ad4b52b1b15b260d804dc39dbb2a5886f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WORD cbufGetFreeForPacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets number of free bytes available in buffer for a packet (packet data). This is how much space is available for the data part of a packet. This function can be called before calling <a class="el" href="nz__circular_buffer_8h.html#a4fd6a9aa372df330bd88444bb0ee61ac">cbufPutPacket()</a> to see if there is enough space to add a packet.</p>
<dl class="section user"><dt>Pre-Condition:</dt><dd>This must be a "Packet Buffer"!</dd></dl>
<p>For <b>Multi Threaded Applications</b>, call from "PUT context".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns number of free bytes available in buffer for the data part of a packet. </dd></dl>

</div>
</div>
<a class="anchor" id="adc537ea5067bd52e8260ffc3ac47d493"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WORD cbufGetPacketDataSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if size part of packet(size of packet data) is in buffer, and if so, get and remove it. No check is done to see if data part of packet is already in buffer. The packet size is a value from 1 to 254 for a normal "Packet Circular Buffer", and 1-65279 for a large "Packet Circular Buffer". It gives the size of the data part of the packet to follow. After calling this function, the data part remains in the buffer and MUST be processed and removed! Use <a class="el" href="nz__circular_buffer_8h.html#afdb0634abd6f6e886a005edfe91997aa">cbufPeekPacketDataSize()</a> to get size without removing it.</p>
<p>For <b>Multi Threaded Applications</b>, call from "GET context".</p>
<dl class="section user"><dt>Pre-Condition:</dt><dd>This must be a "Packet Buffer"!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF circular buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns size of packet data. A value from 1 to 254 for a normal "Packet Circular
Buffer", and 1-65279 for a large "Packet Circular Buffer". Returns 0 if buffer empty, OR does not contain a packet, OR size part of packet not available. </dd></dl>

</div>
</div>
<a class="anchor" id="a8e489cc2f6a8d09973fa76fd85c2a676"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BYTE* cbufGetRdArr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get byte pointer to current GET location. Use this function with <a class="el" href="nz__circular_buffer_8h.html#aea030acb25382f54ed304d684b1614d9">cbufGetRdArrSize()</a> function.</p>
<p>For <b>Multi Threaded Applications</b>, call from "GET context".</p>
<dl class="section return"><dt>Returns</dt><dd>BYTE pointer to current GET location </dd></dl>

</div>
</div>
<a class="anchor" id="aea030acb25382f54ed304d684b1614d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WORD cbufGetRdArrSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets number of contiguous bytes that can be read from buffer. Bytes are NOT removed! Call cbufRemoveBytes(n) to remove bytes if required. Bytes can be read from cirbuf.buf[ cirbuf.get ]. Call <a class="el" href="nz__circular_buffer_8h.html#a579f2af0e162697025c54bd7c1026203">cbufHasData()</a> to see if more bytes available when done. Note that if available bytes cross buffer end boundry, there will be 2 congiguous blocks of data.</p>
<p>!!!! IMPORTANT !!!! Remember to call cbufRemoveBytes(n) to remove bytes if required.</p>
<p>For Eexample: WORD size, byteWritten; //Get number of bytes available for reading size = cbufGetRdArrSize(&amp;cirbuf); //Call some function that requires an array and size as input parameters byteWritten = usbPutArr( cbufGetRdArr(&amp;cirbuf), size); //Now remove bytes from buffer cbufRemoveBytes(&amp;cirbuf, byteWritten);</p>
<p>For <b>Multi Threaded Applications</b>, call from "GET context".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes available in returned buffer </dd></dl>

</div>
</div>
<a class="anchor" id="a9444a521104ea2392b4b2e79990b17eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WORD cbufGetString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE *&#160;</td>
          <td class="paramname"><em>pDstArr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WORD&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets a string from the "Circular Buffer", and copies it to given destination array. The string is remove them from source "Circular Buffer". The actual number of bytes copied is returned. Is only done if a string is found, or end of source buffer reached. Returns number of bytes copied.</p>
<p>If size is exceeded, -1 is returned, and no bytes are removed from source buffer! A side affect is that bytes will still be copied to given destination array (pDstArr), but nothing is removed from source buffer!</p>
<p>!!!! IMPORTANT !!!! Note that if given byte not found, or end of source buffer not reached, nothing is removed from source buffer and -1 is returned. This is the case if the size of the given destination array (size parameter) is reached. Bytes (size) are still copied to destination array (pDstArr).</p>
<p>For <b>Multi Threaded Applications</b>, call from "GET context".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to source CIRBUF structure, that data is copied from </td></tr>
    <tr><td class="paramname">pDstArr</td><td>Pointer to destination BYTE array </td></tr>
    <tr><td class="paramname">size</td><td>Maximum number of bytes to copy. Could be less if pBuf contains less</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns number of bytes added to array. </dd></dl>

</div>
</div>
<a class="anchor" id="a3eccf756cb70b14b4ef500acb66b622e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BYTE cbufGetType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns this buffer's type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns this buffer's type, is a CIRBUF_TYPE_XXX constant </dd></dl>

</div>
</div>
<a class="anchor" id="a3bd77db38205402ed87cf138d2df8f6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BYTE* cbufGetWrArr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function for getting byte pointer to current PUT location. Use this function with <a class="el" href="nz__circular_buffer_8h.html#a8dc6c70941aaca490c86433ee87ecea6">cbufGetWrArrSize()</a> function.</p>
<p>For <b>Multi Threaded Applications</b>, call from "PUT context".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Byte pointer to put buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="a8dc6c70941aaca490c86433ee87ecea6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WORD cbufGetWrArrSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets number of contiguous bytes that can be written to buffer. Buffer PUT pointer is NOT updated! Call <a class="el" href="nz__circular_buffer_8h.html#a19b647cec69d4f420e08a08c8422d673">cbufUpdatePut()</a> to update PUT pointer. Bytes can be written to cirbuf.buf[ cirbuf.put ]. Call <a class="el" href="nz__circular_buffer_8h.html#aaa470ac2cbb00d8a031a8f8062f261bd">cbufIsFull()</a> to see if more bytes can be written when done (and PUT pointer updated). Note that if available bytes cross buffer end boundry, there will be 2 congiguous blocks of data.</p>
<p>!!!! IMPORTANT !!!! Remember to call <a class="el" href="nz__circular_buffer_8h.html#a19b647cec69d4f420e08a08c8422d673">cbufUpdatePut()</a> to update PUT pointer after adding bytes to array.</p>
<p>For Example: WORD size, bytesRead; //Get number of bytes available that can be written to buffer array size = cbufGetWrArrSize(&amp;cirbuf); //Call some function that requires an array and size as input parameters bytesRead = usbGetArr( cbufGetWrArr(&amp;cirbuf), size); //Now update PUT pointer with bytes written cbufUpdatePut(&amp;cirbuf, bytesRead);</p>
<p>For <b>Multi Threaded Applications</b>, call from "PUT context".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes available in returned buffer </dd></dl>

</div>
</div>
<a class="anchor" id="a579f2af0e162697025c54bd7c1026203"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL cbufHasData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if the given buffer contains data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the given buffer has data. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="cirbuf_demo1_2main_8c-example.html#a11">cirbuf_demo1/main.c</a>, <a class="el" href="uart_debug_demo1_2main_8c-example.html#a4">uart_debug_demo1/main.c</a>, and <a class="el" href="usb_2device__m_i_d_i__l_c_d_2main_8c-example.html#a3">usb/device_MIDI_LCD/main.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="af00a8ce0f071a8a966bc66294fdd9081"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WORD cbufHasWholePacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates if given buffer contains a whole packet.</p>
<p>For <b>Multi Threaded Applications</b>, call from "GET context".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 if false, else size of Packet (size of whole packet = [Size] and [Data] part of packet). </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="cirbuf_demo1_2main_8c-example.html#a15">cirbuf_demo1/main.c</a>, <a class="el" href="cirbuf_packet_demo_2main_8c-example.html#a6">cirbuf_packet_demo/main.c</a>, <a class="el" href="db66dev1_debug_demo_2main_8c-example.html#a6">db66dev1_debug_demo/main.c</a>, <a class="el" href="device__h_i_d_debug_demo_2main_8c-example.html#a3">device_HID_debug_demo/main.c</a>, <a class="el" href="i2c_debug_demo_2main_8c-example.html#a6">i2c_debug_demo/main.c</a>, <a class="el" href="ow_ds2482_async_debug_2main_8c-example.html#a10">ow_ds2482_async_debug/main.c</a>, <a class="el" href="ow_ds2482_demo1_debug_2main_8c-example.html#a7">ow_ds2482_demo1_debug/main.c</a>, <a class="el" href="pt66din6_debug_demo_2main_8c-example.html#a7">pt66din6_debug_demo/main.c</a>, <a class="el" href="rotary_encoder_2main_8c-example.html#a12">rotary_encoder/main.c</a>, <a class="el" href="rtc_debug_demo_2main_8c-example.html#a5">rtc_debug_demo/main.c</a>, <a class="el" href="sensor_dht11_dht22_2main_8c-example.html#a13">sensor_dht11_dht22/main.c</a>, <a class="el" href="sensor_dht11_dht22_block_2main_8c-example.html#a7">sensor_dht11_dht22_block/main.c</a>, <a class="el" href="template_project_debug_2main_8c-example.html#a5">template_project_debug/main.c</a>, <a class="el" href="uart_debug_demo1_2main_8c-example.html#a9">uart_debug_demo1/main.c</a>, and <a class="el" href="uart_xc16_demo1_2main_8c-example.html#a6">uart_xc16_demo1/main.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a52ea37f827a113e2451b36e8ce603f2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cbufInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE *&#160;</td>
          <td class="paramname"><em>bufArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WORD&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>typeFormat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Buffer initialization. Buffer type and format is configured via typeFormat parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure</td></tr>
    <tr><td class="paramname">bufArray</td><td>Pointer to buffer array that is used for the this CIRBUF objects internal storage. Must have at least 'size' bytes available.</td></tr>
    <tr><td class="paramname">size</td><td>Size of this buffer.</td></tr>
    <tr><td class="paramname">typeFormat</td><td>Gives the 'type' and 'format' of the buffer. Is an ORed combination of CIRBUF_FORMAT_XX and CIRBUF_TYPE_XX defines. For example: (CIRBUF_FORMAT_NONE | CIRBUF_TYPE_STREAMING) </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="cirbuf_demo1_2main_8c-example.html#a1">cirbuf_demo1/main.c</a>, and <a class="el" href="cirbuf_packet_demo_2main_8c-example.html#a1">cirbuf_packet_demo/main.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="adfb2a7b92818bd34c1296738baf4488a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cbufInitDefault </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE *&#160;</td>
          <td class="paramname"><em>bufArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WORD&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default Buffer initialization. Buffer type is set to streaming (no packet formatting), and with no formatting. Use this function creating a basic buffer with no formatting. Bytes are added and removed in serial fashion. Use <a class="el" href="nz__circular_buffer_8h.html#a52ea37f827a113e2451b36e8ce603f2b">cbufInit()</a> function to initialize buffer with different type and formatting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure</td></tr>
    <tr><td class="paramname">bufArray</td><td>Pointer to buffer array that is used for the this CIRBUF objects internal storage. Must have at least 'size' bytes available.</td></tr>
    <tr><td class="paramname">size</td><td>Size of this buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aee28b1631393336e0bcda4901f0fea95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL cbufIsEmpty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if the given buffer is empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the given buffer is empty. Else, returns false. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="cirbuf_demo1_2main_8c-example.html#a6">cirbuf_demo1/main.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="aaa470ac2cbb00d8a031a8f8062f261bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL cbufIsFull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if the given transmit buffer is full - no more space for adding data. This is the case when put+1 = get</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the given buffer is full. Else, returns false. </dd></dl>

</div>
</div>
<a class="anchor" id="a46f4f447d3d2c50500a607740d635560"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL cbufIsPacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates if given buffer is a "Packet Type" buffer. If true, the <a class="el" href="nz__circular_buffer_8h.html#a00d23bc5d7b35391fc96fcc3fa027287">cbufIsPacketLarge()</a> function can be used to determine if it is a normal or large "Packet Circular Buffer".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 1 if this is a Packet buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="a00d23bc5d7b35391fc96fcc3fa027287"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL cbufIsPacketLarge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates if the given buffer is a "Large Packet Type" buffer. This is the case if the bPacketLarge flag is set. <br/>
!!! IMPORTANT !!!<br/>
 This function does not check it is is a packet, but only the bPacketLarge flag. This flag is only valid if this buffer is a packet type. First use <a class="el" href="nz__circular_buffer_8h.html#a46f4f447d3d2c50500a607740d635560">cbufIsPacket()</a> function to check if this buffer is a packet. To check if this buffer is a packet AND if it is a large packet, use: if (<a class="el" href="nz__circular_buffer_8h.html#a46f4f447d3d2c50500a607740d635560">cbufIsPacket()</a> &amp;&amp; <a class="el" href="nz__circular_buffer_8h.html#a00d23bc5d7b35391fc96fcc3fa027287">cbufIsPacketLarge()</a>) { .... }</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 1 if this is Large Packet buffer (has a 16-bit size field). </dd></dl>

</div>
</div>
<a class="anchor" id="ab743e216fb9c7108223f01395757bac9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WORD cbufMove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBufSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBufDst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves as many bytes as possible from given source buffer (BIFCIR), to given destination buffer (CIRBUF). This function checks how many Source bytes are available, and maximum number of bytes that can be added to Destination.</p>
<p>!! IMPORTANT !! When using in multi threaded application, ensure function is not interrupted by other tasks that can modify the source or destination buffers!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBufSrc</td><td>Pointer to Source CIRBUF structure </td></tr>
    <tr><td class="paramname">pBufDst</td><td>Pointer to Source CIRBUF structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns number of bytes moved from source to destination buffers. </dd></dl>

</div>
</div>
<a class="anchor" id="a5ce13d16c59e3a6e02d750c462d9aad6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WORD cbufPacketStrcmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compares given string to contents of Packet.</p>
<p>For <b>Multi Threaded Applications</b>, call from "GET context".</p>
<dl class="section user"><dt>Pre-Condition:</dt><dd>The buffer must contain a Packet. Use <a class="el" href="nz__circular_buffer_8h.html#af00a8ce0f071a8a966bc66294fdd9081">cbufHasWholePacket()</a> function prior to calling this function to check if the buffer contains a whole packet!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure</td></tr>
    <tr><td class="paramname">str</td><td>String to compare contents of packet to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 if string matches contents of buffer. The lenght is also checked, and buffer contents must be same as strings length. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="cirbuf_demo1_2main_8c-example.html#a16">cirbuf_demo1/main.c</a>, <a class="el" href="cirbuf_packet_demo_2main_8c-example.html#a13">cirbuf_packet_demo/main.c</a>, <a class="el" href="db66dev1_debug_demo_2main_8c-example.html#a7">db66dev1_debug_demo/main.c</a>, <a class="el" href="device__h_i_d_debug_demo_2main_8c-example.html#a4">device_HID_debug_demo/main.c</a>, <a class="el" href="i2c_debug_demo_2main_8c-example.html#a7">i2c_debug_demo/main.c</a>, <a class="el" href="ow_ds2482_async_debug_2main_8c-example.html#a11">ow_ds2482_async_debug/main.c</a>, <a class="el" href="ow_ds2482_demo1_debug_2main_8c-example.html#a8">ow_ds2482_demo1_debug/main.c</a>, <a class="el" href="pt66din6_debug_demo_2main_8c-example.html#a8">pt66din6_debug_demo/main.c</a>, <a class="el" href="rotary_encoder_2main_8c-example.html#a13">rotary_encoder/main.c</a>, <a class="el" href="rtc_debug_demo_2main_8c-example.html#a6">rtc_debug_demo/main.c</a>, <a class="el" href="sensor_dht11_dht22_2main_8c-example.html#a14">sensor_dht11_dht22/main.c</a>, <a class="el" href="sensor_dht11_dht22_block_2main_8c-example.html#a8">sensor_dht11_dht22_block/main.c</a>, <a class="el" href="template_project_debug_2main_8c-example.html#a6">template_project_debug/main.c</a>, <a class="el" href="uart_debug_demo1_2main_8c-example.html#a10">uart_debug_demo1/main.c</a>, and <a class="el" href="uart_xc16_demo1_2main_8c-example.html#a7">uart_xc16_demo1/main.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a803165bec5c4642312e1b47ddba6e802"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BYTE cbufPeekByte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets a byte from the Buffer, without removing it. The byte is NOT removed from the buffer, and the buffer pointers are NOT updated! To remove the byte, and update the pointers, call the <a class="el" href="nz__circular_buffer_8h.html#aa0cc2806944c8d224fb550bd2eb8abc3">cbufRemoveByte()</a> function.</p>
<p>For <b>Multi Threaded Applications</b>, call from "GET context".</p>
<dl class="section user"><dt>Pre-Condition:</dt><dd><a class="el" href="nz__circular_buffer_8h.html#aee28b1631393336e0bcda4901f0fea95">cbufIsEmpty()</a> must have been called to confirm the Buffer has data!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the next byte in the given buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="ad5ecd83b7bc6a9102750b94c840dc2d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BYTE cbufPeekByteAt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WORD&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets a byte at the given offset from the Buffer, without removing it. The byte is NOT removed from the buffer, and the buffer pointers are NOT updated! The byte at the given offset it returned. The offset is how deep the byte is in the buffer. For example, 0 will return first byte in buffer, 5 will return the 6th byte in the buffer.</p>
<p>For <b>Multi Threaded Applications</b>, call from "GET context".</p>
<dl class="section user"><dt>Pre-Condition:</dt><dd>Ensure offset parameter is not larger than current number of byte contained in buffer. Call <a class="el" href="nz__circular_buffer_8h.html#a4b57fbfd7719fe18b0cdfa42594f6824">cbufGetCount()</a> to get current number of bytes in buffer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure </td></tr>
    <tr><td class="paramname">offset</td><td>Offset of byte to return. Is a value from 0-n, where n = (<a class="el" href="nz__circular_buffer_8h.html#a4b57fbfd7719fe18b0cdfa42594f6824">cbufGetCount()</a> - 1)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the byte at the given offset in the given buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="a7826fc3569e8a6701451d2978fbac165"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BYTE cbufPeekEscapedByte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets a byte from the Buffer, taking "escape characters" into account. The returned byte is NOT removed from the buffer, and the buffer pointers are NOT updated! To remove the byte, and update the pointers, call the <a class="el" href="nz__circular_buffer_8h.html#aa0cc2806944c8d224fb550bd2eb8abc3">cbufRemoveByte()</a> function.</p>
<p>If the first byte in the buffer is an "escape character", the second byte is returned.</p>
<ul>
<li>If this byte is another "escape character", it represents a single character with the same value as the "escape character". This function returns 0, and the read character is returned via the "b" parameter</li>
<li>If this byte is NOT the "escape character", it is a "control character". This function returns 1, and the control character is returned via the "b" parameter</li>
</ul>
<p>For <b>Multi Threaded Applications</b>, call from "GET context".</p>
<dl class="section user"><dt>Pre-Condition:</dt><dd><a class="el" href="nz__circular_buffer_8h.html#a4b57fbfd7719fe18b0cdfa42594f6824">cbufGetCount()</a> must have been called to confirm the buffer has AT LEAST 2 bytes available to read!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure</td></tr>
    <tr><td class="paramname">b</td><td>Pointer to BYTE for returned character. This function will place the returned character in the byte pointed to by this parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 if a normal byte is returned, else 1 if a "control character" is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a6217f5ddf36757340831b3b6524c95b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BYTE cbufPeekPacketByte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the first byte of the Packet data, without removing it.</p>
<p>For <b>Multi Threaded Applications</b>, call from "GET context".</p>
<dl class="section user"><dt>Pre-Condition:</dt><dd>This must be a "Packet Buffer", and there MUST be a packet available! Use <a class="el" href="nz__circular_buffer_8h.html#af00a8ce0f071a8a966bc66294fdd9081">cbufHasWholePacket()</a> function to check if there is a packet available!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF circular buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns first byte of Packet's data. </dd></dl>

</div>
</div>
<a class="anchor" id="afdb0634abd6f6e886a005edfe91997aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WORD cbufPeekPacketDataSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns size of packet data. Nothing is removed from the buffer! The packet size is a value from 1 to 254 for a normal "Packet Circular Buffer", and 1-65279 for a large "Packet Circular Buffer". It gives the size of the data part of the packet to follow.</p>
<p>For <b>Multi Threaded Applications</b>, call from "GET context".</p>
<dl class="section user"><dt>Pre-Condition:</dt><dd>The buffer must contain a Packet. Use <a class="el" href="nz__circular_buffer_8h.html#af00a8ce0f071a8a966bc66294fdd9081">cbufHasWholePacket()</a> function prior to calling this function to check if the buffer contains a whole packet!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF circular buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns size of packet data. A a value from 1 to 254 for a normal "Packet
Circular Buffer", and 1-65279 for a large "Packet Circular Buffer". </dd></dl>

</div>
</div>
<a class="anchor" id="aadb51357e524712ba817c7b822c3cdae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WORD cbufPutArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BYTE *&#160;</td>
          <td class="paramname"><em>pSrcArr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WORD&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds given number of bytes to buffer. This function checks given buffer has enough space. The actual number of bytes written is returned.</p>
<p>For <b>Multi Threaded Applications</b>, call from "PUT context".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure </td></tr>
    <tr><td class="paramname">pSrcArr</td><td>Pointer to source BYTE array </td></tr>
    <tr><td class="paramname">size</td><td>Number of bytes to copy</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns number of bytes added to buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="a45d560503f0edcc7d5bdb906e63adf7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WORD cbufPutArrayWait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BYTE *&#160;</td>
          <td class="paramname"><em>pSrcArr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WORD&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds given number of bytes to buffer. If buffer does not have enough space, this function will wait until space is available in buffer to add requested bytes. !!!!! IMPORTANT !!!!! Only call this function for buffers that use ISR to empty buffer. Else, buffer will never get empty if we wait for it!</p>
<p>For <b>Multi Threaded Applications</b>, call from "PUT context".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure </td></tr>
    <tr><td class="paramname">pSrcArr</td><td>Pointer to source BYTE array </td></tr>
    <tr><td class="paramname">size</td><td>Number of bytes to copy</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns number of bytes added to buffer. If a timeout occurred, it will be less then the requested size. </dd></dl>

</div>
</div>
<a class="anchor" id="a7364bd37a4e83828296b92902eb7de68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WORD cbufPutAsciiEscString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>cbufDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>cbufSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pStrSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WORD&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section user"><dt>Function:</dt><dd>WORD <a class="el" href="nz__circular_buffer_8h.html#a7364bd37a4e83828296b92902eb7de68">cbufPutAsciiEscString(CIRBUF* cbufDst, CIRBUF* cbufSrc, const char* pStrSrc, WORD flags)</a></dd></dl>
<p>Adds the given string (in ASCII format, with escape sequences) to the given destination.</p>
<p>The source must be an ASCII String, and can contain Escape Sequences.<br/>
 The destination is a "Circular Buffer", and must be in "Binary Format, with Escape Sequence". It can be a normal (Streaming) or "Packet" type "Circular Buffer".<br/>
 This function will decoded the source, and add it to the destination as binary data.</p>
<p>For details on formats, see <a class="el" href="nz__circular_buffer_8h.html#nz_circularBuffer_format_ascii_esc">ASCII Format, with Escape Sequences</a>, and <a class="el" href="nz__circular_buffer_8h.html#nz_circularBuffer_format_bin_esc">Binary Format, with Escape Sequence</a>. For details on "Circular Buffer" types, see <a class="el" href="nz__circular_buffer_8h.html#nz_circularBuffer_type_streaming">Circular Buffers</a> and <a class="el" href="nz__circular_buffer_8h.html#nz_circularBuffer_type_packet">Packet Type Circular Buffers</a>.</p>
<p>The source can be a String, "Circular Buffer" or "Packet Type Circular Buffer"</p>
<ul>
<li><b>String:</b> Give string in the pStrSrc parameter, and NULL in cbufSrc parameter. The string must be NULL terminated!</li>
<li><b>Circular Buffer:</b> Give "Circular Buffer" in the cbufSrc parameter, and NULL in pStrSrc parameter. The "Circular Buffer" must contain a NULL terminated string.</li>
<li><b>Packet Type Circular Buffer:</b> Give "Circular Buffer" in the cbufSrc parameter, and NULL in pStrSrc parameter. If the packet contains a NULL terminated string, it is added. Else, the first packet is added to the destination.</li>
</ul>
<p>If destination "Circular Buffer" did not have enough space to add data:</p>
<ul>
<li>NOTHING is added to the destination "Circular Buffer".</li>
<li>NOTHING is removed from the source "Circular Buffer" (if source is a "Circular Buffer").</li>
</ul>
<p>Else:</p>
<ul>
<li>All processed bytes are removed from the source "Circular Buffer" (if source is a "Circular Buffer").</li>
</ul>
<p>For <b>Multi Threaded Applications</b>, call from "PUT context".</p>
<dl class="section user"><dt>Pre-Condition:</dt><dd>If source is a Packet type "Circular Buffer", it MUST contain a whole packet.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cbufDst</td><td>Is the destination "Circular Buffer"</td></tr>
    <tr><td class="paramname">cbufSrc</td><td>If not NULL, is pointer to source "Circular Buffer".<ul>
<li>If Packet type, all bytes from next packet are processed and added to destination.</li>
<li>Else all bytes till NULL character (end of string) are processed and added to destination.</li>
</ul>
</td></tr>
    <tr><td class="paramname">pStrSrc</td><td>If cbufSrc=NULL, this must contain the source as a NULL terminated string.</td></tr>
    <tr><td class="paramname">flags</td><td>A combination of ASCIIESC_XXX flags that add aditional functionality:<ul>
<li>ASCIIESC_ADD_S_AND_P: Adds a 's' and 'p' control character to front and back of destination.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns number of bytes added to buffer. Zero is returned if destination "Circular Buffer" did not have enough space to add string. In this case, nothing is added to the buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="ad56769cd53384959977771c1f1fe3529"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BYTE cbufPutByte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a BYTE to the buffer, and updates the buffer pointers. This function checks given buffer has enough space(1 byte) to add BYTE. If the destination buffer has enough space, 1 byte will be added.</p>
<p>For <b>Multi Threaded Applications</b>, call from "PUT context".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure </td></tr>
    <tr><td class="paramname">b</td><td>Byte to add to the buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns number of bytes added to buffer, will be 0 or 1. Returns 0 if buffer did not have enough space to add given byte. In this case, nothing is added to the buffer. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="cirbuf_demo1_2main_8c-example.html#a7">cirbuf_demo1/main.c</a>, <a class="el" href="uart_debug_demo1_2main_8c-example.html#a8">uart_debug_demo1/main.c</a>, and <a class="el" href="usb_2device__m_i_d_i__l_c_d_2main_8c-example.html#a2">usb/device_MIDI_LCD/main.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a5984299178eba4ab8f8de13159c3d4e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BYTE cbufPutByteAscii </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a BYTE in decimal format to the buffer, and updates the buffer pointers. For example, cbufPutByteAscii(100) will add the string "100" to the buffer. The NULL terminator is NOT included. This function checks given buffer has enough space to add string.</p>
<p>For <b>Multi Threaded Applications</b>, call from "PUT context".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure </td></tr>
    <tr><td class="paramname">b</td><td>Byte to add to the buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns number of bytes added to buffer. Zero is returned if buffer did not have enough space to add string. In this case, nothing is added to the buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="adba91368037807a9509446eb526471bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BYTE cbufPutByteAsciiHex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds given BYTE as a "2-Character Uppercase ASCII Hex Formatted String" to the buffer, and updates the buffer pointers. For example, cbufPutByteAscii(0x5A) will add the string "5A" to the buffer. The NULL terminator is NOT included. This function checks given buffer has enough space to add string.</p>
<p>For <b>Multi Threaded Applications</b>, call from "PUT context".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure </td></tr>
    <tr><td class="paramname">b</td><td>Byte to add to the buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns number of bytes added to buffer, will be 0 or 2. Zero is returned if buffer did not have enough space to add string. In this case, nothing is added to the buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="a85db23225422115836736bdfb51986fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cbufPutByteNoCheck </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a BYTE to the buffer, and updates the buffer pointers. No check is done to see if there is space available in the buffer!</p>
<dl class="section user"><dt>Pre-Condition:</dt><dd><a class="el" href="nz__circular_buffer_8h.html#aaa470ac2cbb00d8a031a8f8062f261bd">cbufIsFull()</a> must have been called to confirm the buffer is not full!</dd></dl>
<p>For <b>Multi Threaded Applications</b>, call from "PUT context".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure </td></tr>
    <tr><td class="paramname">b</td><td>Byte to add to the buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5ec513956e1e3c33e29ec996ae9c9134"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BYTE cbufPutControlChar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add an "Escape Character" and given byte to buffer. The default escape character is '^'. This function is used to add special control characters to the buffer.</p>
<dl class="section user"><dt>Pre-Condition:</dt><dd>buffer must have space, this function does NOT check if there is space in the buffer! Use <a class="el" href="nz__circular_buffer_8h.html#ae0217704752fe13b84a324f4b1a2cd35">cbufGetFree()</a> to get free space for writing.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure</td></tr>
    <tr><td class="paramname">b</td><td>Byte to add to the buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 if ERROR, else number of bytes added to buffer. Will be 2 if successfull (escape character and given byte). </dd></dl>

</div>
</div>
<a class="anchor" id="a5ea929081c8ff25fa59ee696ac9c406b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BYTE cbufPutEscapedByte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add the given byte to the buffer. If it is equal to the "Escape Character", it has to be preceded by an additional escape characters(escaped). The default escape character is '^'. When reading back the buyte with cbufGetEscapedByte, the original bytes will be read (excluding any escape characters that might have been added).</p>
<dl class="section user"><dt>Pre-Condition:</dt><dd>buffer must have space, this function does NOT check if there is space in the buffer! Use <a class="el" href="nz__circular_buffer_8h.html#ae0217704752fe13b84a324f4b1a2cd35">cbufGetFree()</a> to get free space for writing.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure</td></tr>
    <tr><td class="paramname">b</td><td>Byte to add to the buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 if ERROR, else number of bytes added to buffer.<br/>
 Returns 2 if given byte was the "Escape Character" (had to be escaped with additional character)<br/>
 Returns 1 if single byte added to buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="a4fd6a9aa372df330bd88444bb0ee61ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WORD cbufPutPacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BYTE *&#160;</td>
          <td class="paramname"><em>pSrcArr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WORD&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds given number of bytes to buffer as a packet. This function checks given buffer has enough space, and either adds all given bytes, or nothing (not enough space). A Packet buffer has the format: [Size][Data] The size parameter must give the size of the source BYTE array (pSrcArr parameter). It will be copied to the [Data] part of the Packet. The [Size] part can be a 8 or 16-bit value, depending if it is a normal or large packet buffer. Use the <a class="el" href="nz__circular_buffer_8h.html#a00d23bc5d7b35391fc96fcc3fa027287">cbufIsPacketLarge()</a> to determine if normal or large. When normal, function will fail if the size parameter is larger than 254.</p>
<p>The <a class="el" href="nz__circular_buffer_8h.html#ad4b52b1b15b260d804dc39dbb2a5886f">cbufGetFreeForPacket()</a> function can be called prior to calling this function to check if there is enough space. But if not called, and there is not enough space, this function will return with 0 without any error occuring!</p>
<dl class="section user"><dt>Pre-Condition:</dt><dd>This must be a "Packet Buffer"!</dd></dl>
<p>For <b>Multi Threaded Applications</b>, call from "PUT context".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to destination CIRBUF Circular Buffer. Packet is added to this buffer. </td></tr>
    <tr><td class="paramname">pSrcArr</td><td>Pointer to source BYTE array. This is copied to the [Data] part of packet. </td></tr>
    <tr><td class="paramname">size</td><td>Size of source BYTE array(pSrcArr).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns number of bytes added to buffer. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="cirbuf_packet_demo_2main_8c-example.html#a8">cirbuf_packet_demo/main.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="aaf805c529e964381d5c1d5e8e98e893d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WORD cbufPutString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds given NULL terminated string to buffer, and updates the buffer pointers. The NULL terminator is NOT included (not written to buffer!) This function checks given buffer has enough space to add string.</p>
<p>For <b>Multi Threaded Applications</b>, call from "PUT context".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure</td></tr>
    <tr><td class="paramname">s</td><td>Null terminated string to add</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns number of bytes added to buffer. Zero is returned if buffer did not have enough space to add string. In this case, nothing is added to the buffer. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="cirbuf_demo1_2main_8c-example.html#a10">cirbuf_demo1/main.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ab7c0ba7ff14038bfa2f2679c1fbdcf96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WORD cbufPutStringWait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds given NULL terminated string to buffer, and updates the buffer pointers. If the buffer is full, this function will wait until space is available in buffer to add string. !!!!! IMPORTANT !!!!! Only call this function for buffers that use ISR to empty buffer. Else, buffer will never get empty if we wait for it!</p>
<p>For <b>Multi Threaded Applications</b>, call from "PUT context".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure </td></tr>
    <tr><td class="paramname">s</td><td>String to add to the buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns number of bytes added to buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="a8ce7844e0cdf684a3ca0d47ffaf690ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BYTE cbufPutWord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WORD&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a WORD to the buffer, and updates the buffer pointers. This function checks given buffer has enough space(2 bytes) to add WORD. If the destination buffer has enough space, 2 bytes will always be added to the buffer, first the LSB followed by the MSB.</p>
<p>For <b>Multi Threaded Applications</b>, call from "PUT context".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure </td></tr>
    <tr><td class="paramname">w</td><td>Word to add to the buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns number of bytes added to buffer, will be 0 or 2. Returns 0 if buffer did not have enough space to add given word. In this case, nothing is added to the buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="ac28dd8f3c542f4151419dc3a0ea8fa9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BYTE cbufPutWordAscii </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WORD&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a WORD in decimal format to the buffer, and updates the buffer pointers. For example, cbufPutByteAscii(100) will add the string "100" to the buffer. The NULL terminator is NOT included. This function checks given buffer has enough space to add string.</p>
<p>For <b>Multi Threaded Applications</b>, call from "PUT context".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure </td></tr>
    <tr><td class="paramname">w</td><td>Word to add to the buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns number of bytes added to buffer. Zero is returned if buffer did not have enough space to add string. In this case, nothing is added to the buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="a907ced88795565ff9ffc6c208667a001"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BYTE cbufPutWordAsciiHex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WORD&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds given WORD as a "4-Character Uppercase ASCII Hex Formatted String" to the buffer, and updates the buffer pointers. For example, cbufPutByteAscii(0x065A) will add the string "065A" to the buffer. The NULL terminator is NOT included. This function checks given buffer has enough space to add string.</p>
<p>For <b>Multi Threaded Applications</b>, call from "PUT context".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure </td></tr>
    <tr><td class="paramname">w</td><td>Byte to add to the buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns number of bytes added to buffer, will be 0 or 4. Zero is returned if buffer did not have enough space to add string. In this case, nothing is added to the buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="aa0cc2806944c8d224fb550bd2eb8abc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cbufRemoveByte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes a byte from the Buffer. Removes bytes from the back of the circular buffer (from GET pointer). The same as <a class="el" href="nz__circular_buffer_8h.html#a6b28e2ed0c70bc8e885f4598e98b3ed6">cbufGetByte()</a> will remove the byte read!</p>
<dl class="section user"><dt>Pre-Condition:</dt><dd>Before calling this function, it must be confirmed that the buffer has data. The <a class="el" href="nz__circular_buffer_8h.html#a579f2af0e162697025c54bd7c1026203">cbufHasData()</a> is an example function that can be used to do this check.</dd></dl>
<p>For <b>Multi Threaded Applications</b>, call from "GET context".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae0f867ce6449e44ac7ba4083cf09c27d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cbufRemoveBytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WORD&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes given number of bytes from the Buffer.</p>
<dl class="section user"><dt>Pre-Condition:</dt><dd>Before calling this function, it must be confirmed that the buffer has the requested number of bytes to remove.</dd></dl>
<p>!!! IMPORTANT !!! If more bytes are requested to be removed then available, bad things will happen!!!!!!!!</p>
<p>For <b>Multi Threaded Applications</b>, call from "GET context".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure </td></tr>
    <tr><td class="paramname">n</td><td>Number of bytes to remove </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a41ff25acfdec531e69b8437abb11b720"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cbufRemovePacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if there is a packet in the buffer, and if so, removes it.</p>
<dl class="section user"><dt>Pre-Condition:</dt><dd>This must be a "Packet Buffer"!</dd></dl>
<p>For <b>Multi Threaded Applications</b>, call from "GET context".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="cirbuf_demo1_2main_8c-example.html#a17">cirbuf_demo1/main.c</a>, <a class="el" href="cirbuf_packet_demo_2main_8c-example.html#a10">cirbuf_packet_demo/main.c</a>, <a class="el" href="db66dev1_debug_demo_2main_8c-example.html#a8">db66dev1_debug_demo/main.c</a>, <a class="el" href="device__h_i_d_debug_demo_2main_8c-example.html#a5">device_HID_debug_demo/main.c</a>, <a class="el" href="i2c_debug_demo_2main_8c-example.html#a8">i2c_debug_demo/main.c</a>, <a class="el" href="ow_ds2482_async_debug_2main_8c-example.html#a12">ow_ds2482_async_debug/main.c</a>, <a class="el" href="ow_ds2482_demo1_debug_2main_8c-example.html#a9">ow_ds2482_demo1_debug/main.c</a>, <a class="el" href="pt66din6_debug_demo_2main_8c-example.html#a9">pt66din6_debug_demo/main.c</a>, <a class="el" href="rotary_encoder_2main_8c-example.html#a14">rotary_encoder/main.c</a>, <a class="el" href="rtc_debug_demo_2main_8c-example.html#a9">rtc_debug_demo/main.c</a>, <a class="el" href="sensor_dht11_dht22_2main_8c-example.html#a15">sensor_dht11_dht22/main.c</a>, <a class="el" href="sensor_dht11_dht22_block_2main_8c-example.html#a9">sensor_dht11_dht22_block/main.c</a>, <a class="el" href="template_project_debug_2main_8c-example.html#a7">template_project_debug/main.c</a>, <a class="el" href="uart_debug_demo1_2main_8c-example.html#a11">uart_debug_demo1/main.c</a>, and <a class="el" href="uart_xc16_demo1_2main_8c-example.html#a8">uart_xc16_demo1/main.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ab3bc759924f6ce0721f5ae5bd5d7a0dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cbufRemovePutByte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes last byte written to the Buffer. Removes bytes from the front of the circular buffer (from PUT pointer). This function is NOT the same as the <a class="el" href="nz__circular_buffer_8h.html#aa0cc2806944c8d224fb550bd2eb8abc3">cbufRemoveByte()</a> function! It should be used to undo a byte added via <a class="el" href="nz__circular_buffer_8h.html#ad56769cd53384959977771c1f1fe3529">cbufPutByte()</a>.</p>
<dl class="section user"><dt>Pre-Condition:</dt><dd>Before calling this function, it must be confirmed that the buffer has data. The <a class="el" href="nz__circular_buffer_8h.html#a579f2af0e162697025c54bd7c1026203">cbufHasData()</a> is an example function that can be used to do this check.</dd></dl>
<p>For <b>Multi Threaded Applications</b>, call from "PUT context".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0f0fbbb5867303684efb705319bb2f9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cbufSetTypeAndFormat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>typeFormat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the Type and Format of the buffer. This is normally done via the <a class="el" href="nz__circular_buffer_8h.html#a52ea37f827a113e2451b36e8ce603f2b">cbufInit()</a> or <a class="el" href="nz__circular_buffer_8h.html#adfb2a7b92818bd34c1296738baf4488a">cbufInitDefault()</a> functions!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure</td></tr>
    <tr><td class="paramname">typeFormat</td><td>Gives the 'type' and 'format' of the buffer. Is an ORed combination of CIRBUF_FORMAT_XX and CIRBUF_TYPE_XX defines. For example: (CIRBUF_FORMAT_NONE | CIRBUF_TYPE_STREAMING) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7886db768e36208bd8ec11a6cfcfcd05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BYTE cbufShaddowPutByte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WORD&#160;</td>
          <td class="paramname"><em>putShaddow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a byte to the buffer, using supplied PUT pointer. Returns updated PUT pointer. The actual PUT pointer of buffer is NOT modified, meaning data is added to buffer, but it will NOT be available for reading by any other threads until commited. Use this function to create thread safe code. Is required when writing data to buffer, that might get changed before done.</p>
<p>For example, when writing a packet, we migth update the packet size (first by of packet) only when done, seeing that we do not know the size until finished. In this case, we do not want any other process reading the packet until we are done!</p>
<p>Call <a class="el" href="nz__circular_buffer_8h.html#ae1f47f9deea38e1136cfce1c4f7e8524">cbufShaddowPutCommit()</a> function to commit all changes made via this function.</p>
<dl class="section user"><dt>Pre-Condition:</dt><dd><a class="el" href="nz__circular_buffer_8h.html#aaa470ac2cbb00d8a031a8f8062f261bd">cbufIsFull()</a> must have been called to confirm the buffer is not full!</dd></dl>
<p>For <b>Multi Threaded Applications</b>, call from "PUT context".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure</td></tr>
    <tr><td class="paramname">b</td><td>Byte to add to the buffer</td></tr>
    <tr><td class="paramname">putShaddow</td><td>Is the shaddow PUT pointer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the updated shaddow PUT pointer. </dd></dl>

</div>
</div>
<a class="anchor" id="ae1f47f9deea38e1136cfce1c4f7e8524"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cbufShaddowPutCommit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WORD&#160;</td>
          <td class="paramname"><em>putShaddow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Commit shaddow PUT pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure</td></tr>
    <tr><td class="paramname">putShaddow</td><td>Shaddow PUT pointer to commit </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a74b2bf7f54e0d38e478ac7f6a645b58a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cbufTask </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Must be called every couple of ms </p>

</div>
</div>
<a class="anchor" id="a19b647cec69d4f420e08a08c8422d673"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cbufUpdatePut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="nz__circular_buffer_8h.html#abe1952d063f6dc2949499653d4ad778c">CIRBUF</a> *&#160;</td>
          <td class="paramname"><em>pBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WORD&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Increments PUT pointer by given size, taking care of any wrapping required. This function is meant to be used after writing bytes to a CIRBUF buffer's array obtained with <a class="el" href="nz__circular_buffer_8h.html#a8dc6c70941aaca490c86433ee87ecea6">cbufGetWrArrSize()</a> function.</p>
<p>For <b>Multi Threaded Applications</b>, call from "PUT context".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pBuf</td><td>Pointer to CIRBUF structure </td></tr>
    <tr><td class="paramname">n</td><td>Size to increment put pointer by </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_0497715779ca99cb1134d5ce544966ba.html">netcruzer</a></li><li class="navelem"><a class="el" href="dir_285a68def6f82363136d1caaa0fe0051.html">lib</a></li><li class="navelem"><a class="el" href="nz__circular_buffer_8h.html">nz_circularBuffer.h</a></li>
    <li class="footer">Generated on Tue Dec 9 2014 15:08:19 for Netcruzer Library API by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.4 </li>
  </ul>
</div>
</body>
</html>
